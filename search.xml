<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[正睿Day7题解]]></title>
    <url>%2F2019%2F10%2F25%2F%E6%AD%A3%E7%9D%BFDay7%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题目下载链接：https://pan.baidu.com/s/124va3buX3cNITjDDXDFVKw提取码：nvt5 字符串考虑如何判断一个字符串 $S$ 是不是另一个字符串 $T$ 的子序列。 一个自然的想法是贪心：我们按照从前往后的顺序考虑 $S$ 的每个字母，然后维护一个 $j$，表示 $S_1S_2 · · · S_i$ 当前的字符已经匹配到了 $T_1T_2 · · · T_j$。然后每次贪心选择下一个使得 $T_{j′} = S_i+1$ 的 $j′$ 匹配过去的。 那么对于这个问题，我们考虑 DP 时记录两个序列对应的 $j$，那么转移时，预处理出每个字符串每个位置后面第一个 $0/1$ 在哪里即可做到 $Θ(1)$ 转移。 时间复杂度：$Θ(n^2)$。 本题的难点在于如何输出字典序最小的方案。考虑从中止状态出发反向遍历，即可得到哪些状态在“起点到终点的最短路”上（我们把 DP 状态看成图论中的节点，那么 DP 结果就相当于最短路了）。 我们考虑从起始状态出发，枚举下一位填什么，如果能到的状态在最短路上，那么就走过去，否则枚举下一个即可构造出来了。 时间复杂度： $Θ(n^2)$。 序列显然每个数字的出现次数应该都是 $2t-1$ 的形式，要不然把多出来的那些换成别的数字一定不会变差。 那么我们考虑有了这个性质之后怎么做。考虑一个贪心做法：我们有一个把每个数字的出现次数从当前的 $2t-1$ 加到 $2t+1-1$ 的代价，然后这个会使得答案变大 $1$。 因此，我们可以每次选择一个最小的，然后把它的出现次数改一下。 那么我们可以发现，我们选择的这些一定代价都不超过某个数字 $M$，因此我们考虑二分 $M$，然后计算出此时需要的总和是多少。这个计算是容易的：因为 $2t ≤ M$ 的t 只有 $Θ(\log_2 N)$ 个，因此可以直接计算。 那么我们在二分得到答案的 M 后，直接再做一遍同样的操作即可。注意恰好等于 $M$ 的那些可能会选一部分，而非全选。 时间复杂度： $Θ(T \log_2^2 N)$。 交换首先假设所有数字互不相同，那么我们按照从小到大的顺序考虑每个数字。 可以发现根据题目要求，它要么放在当前序列的开头，要么放在末尾。 考虑放在开头以及结尾的代价，可以发现如果我们把交换两个数字的代价在较小的那个数字计算，那么这样总代价就是前面以及后面没有被放过去的数字个数之和。 那么根据这个分析，可以发现我们某个数字无论放在前面还是后面，他对于后面的数字影响都是一样的——因为代价只与没有放过去的个数有关。因此，我们可以直接贪心选择放在前面还是后面，于是我们使用树状数组即可求出放在两个位置的代价，然后贪心放过去即可。 时间复杂度： $Θ(n \log_2 n)$。那么还有一个问题：就是如果有一样的数字，那么有可能在他们被交换的时候我们也会计算代价，而这次是可以省掉的。 考虑怎么办。 我们注意到同一个数字的所有出现中，一定不会有前面的数字被放到后面，因为这样反过来放显然会更优。因此，对于同一个数字的所有出现，我们可以考虑类似归并：每次把第一个数放到最前面的代价，以及最后一个数字放到最后面的代价算出来，然后哪个小就放哪个即可。 时间复杂度： $Θ(n \log_2 n)$。]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[求逆序对数的三种方法]]></title>
    <url>%2F2019%2F10%2F24%2F%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[查看例题请戳这里 这里我们从易到难来介绍三种求逆序对数的方法。 top1:暴力枚举时间复杂度：$O(n^2)$ emmmmm…… 这好像真的没什么可说的…… code: 123for(int i = 1; i &lt; n; i++) for(int j = i + 1; j &lt;= n; j++) if(a[i] &gt; a[j]) ans++; top2:归并排序时间复杂度：$O(n\log{n})$ 逆序对怎么还和排序扯上关系了呢qwq？ 是这样的，在归并排序中，我们每次合并两个有序的序列$a,b$，如果$a_i&gt;b_j$，由于a和b都是有序的，那么$a_{i-l_1}&gt;b_j$，所以我们可以直接更新答案：$ans=ans+l_1-a_i+1$ code: 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;long long a[510000],n,b[510000],tj=0;void gb(int l,int r)&#123; if(l==r) return ; int mid=(r+l)/2,i; gb(l,mid); gb(mid+1,r); int l1,l2,r1; l1=l; l2=l; r1=mid+1; while(l1&lt;=mid&amp;&amp;r1&lt;=r) &#123; if(a[l1]&gt;a[r1]) &#123; tj=tj+(mid-l1+1); b[l2++]=a[r1++]; &#125; else &#123; b[l2++]=a[l1++]; &#125; &#125; if(l1&lt;=mid) for(i=l1;i&lt;=mid;i++) b[l2++]=a[i]; if(r1&lt;=r) for(i=r1;i&lt;=r;i++) b[l2++]=a[i]; for(i=l;i&lt;=r;i++) a[i]=b[i];&#125;int main()&#123; int i; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); gb(1,n); cout&lt;&lt;tj; return 0;&#125; top3：树状数组时间复杂度：$O(n\log{n})$ 树状数组求逆序对数大概是最难理解的一种了。 大体思路是我们把下标按照其对应的元素大小从大到小排序以后通过树状数组来快速处理每一个元素对答案的贡献。 首先，我们把给定的序列的下标从大到小排序。需要注意的是，对于指向元素大小相等的坐标，我们应按坐标从大到小排序。（其实这一步就是一个离散化，方便后面树状数组的处理） 1234567891011121314...bool cmp(int x,int y)&#123; if(a[x] != a[y]) return a[x] &gt; a[y]; return x &gt; y;&#125;int main()&#123; n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(),b[i] = i; sort(b + 1, b + n + 1, cmp); ...&#125; 然后，我们按照排完序的坐标序列的顺序来更新答案。 具体思路是这样的： 对于下标$i$，我们在树状数组中使$位置i$加$1$，表示$a[i]$和$aj$会构成一组逆序对，而$i$指向的元素$x$一共会和$query(i-1)$个$ak$构成逆序对。 因为如果在下标序列中，靠前的下标指向的元素一定大于等于靠后的下标指向的元素，而在下标序列中比当前遍历到的下标靠前的下标一定会被优先处理并完成关于该下标答案的统计，所以这样做是正确的。 code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re register#define int long longusing namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;int n,a[1000005],shu[1000005],b[1000005],ans;int lowbit(int x)&#123;return x &amp; (-x);&#125;bool cmp(int x,int y)&#123; if(a[x] != a[y]) return a[x] &gt; a[y]; return x &gt; y;&#125;void updata(int x)&#123; while(x &lt;= n) &#123; shu[x]++; x += lowbit(x); &#125;&#125;int query(int x)&#123; int cnt = 0; while(x &gt; 0) &#123; cnt += shu[x]; x -= lowbit(x); &#125; return cnt;&#125;signed main()&#123; n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(),b[i] = i; sort(b + 1, b + n + 1, cmp); for(int i = 1; i &lt;= n; i++) &#123; updata(b[i]); ans = ans + query(b[i] - 1); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>逆序对</tag>
        <tag>树状数组</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1450 【[HAOI2008]硬币购物】]]></title>
    <url>%2F2019%2F10%2F24%2F%E9%A2%98%E8%A7%A3-P1450-%E3%80%90-HAOI2008-%E7%A1%AC%E5%B8%81%E8%B4%AD%E7%89%A9%E3%80%91%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 看到这道题，最直观的就是对于每一种情况都跑一遍多重背包，然而这样做的话时间复杂度会变得非常奇妙…… 首先，我们可以考虑每种钱的个数没有限制的方案数。很显然，我们可以直接跑一个完全背包。 那么，如果只有一种钱存在个数限制呢？ 我们用$f[i]$表示支付金额$i$的方案数，那么$f[s]$就是硬币没有限制时支付的方案数。如果面值为$c[i]$的硬币的数量为$d[i]$，那么只用c[i]可以支付的最大金额就是$c[i]\times d[i]$。那么，如果我们先花掉$d[i]+1$张面额为$c[i]$的钱，然后再用这$4$种钱去支付剩余的金额，那么无论剩余金额的支付方案是什么，这个放案一定会使用至少$d[i]+1$张$c[i]$，即$c[i]$的使用数量一定会超出限制。 我们再来考虑这些钱全部有数量限制时的情况。 如果我们对于每一种钱都按上面的方案处理，那么对于某种即超出$c[i]$的限制，又超出$c[j]$限制的方案数，我们就会减两遍，所以这里我们需要容斥一下。 code: 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;long long c[5],d[5],ans,tot,s,f[100005],k;int main()&#123; for(int i = 1; i &lt;= 4; i++) scanf("%d",&amp;c[i]); scanf("%d",&amp;tot); f[0] = 1; for(int j = 1; j &lt;= 4; j++) for(int i = 1; i &lt;= 100000; i++) if(i &gt;= c[j]) f[i] = f[i] + f[i - c[j]]; while(tot--) &#123; for(int i = 1; i &lt;= 4; i++) scanf("%d",&amp;d[i]); scanf("%d",&amp;s); ans = f[s]; for(int k = 15;k &gt; 0; k--) &#123; long long u = 0,o = k,now = 0,cnt = 0; while(o &gt; 0) &#123; cnt++; if(o &amp; 1) &#123; now = (d[cnt] + 1) * c[cnt] + now; u ^= 1; &#125; o &gt;&gt;= 1; &#125; if(now &gt; s) continue; if(u) ans -= f[s - now]; else ans += f[s - now]; &#125; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划，dp</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正睿Day6题解]]></title>
    <url>%2F2019%2F10%2F23%2F%E6%AD%A3%E7%9D%BFDay6%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题目链接：https://pan.baidu.com/s/1nXgVYuGv-aavPk7vzkcjaw提取码：hque 爬杆50分做法容易发现，如果可以加梯子，那么$i$到$j(i&lt;j)$的距离是$h_i+h_j-2\min^j_{k=i}h_k+j-i$，因为必须要经过最小的位置。 其中$j-i$这⼀部分可以单独计算，$h_i+h_j$这部分也可以简单计算，剩下的部分是所有区间最小值的和，这个可以使⽤单调栈解决。 100分做法⾸先建出笛卡尔树，也就是每次把序列⾥⾯最⼩的元素拿出来，然后递归左右两边建树。 然后我们考虑贪心的去加梯⼦，⾸先序列中所有的元素都要到达最小值。⽐如说序列是 x x x x x 1 x x x x x 2 x x x x ，那么⼀定是从$2$开始往左建高度为$2$的梯子，然后在和$1$相邻的时候把⾼度降为$1$，因为右边的所有值都不小于$2$，所以建高度低于$2$的梯⼦肯定是不优的。然后递归到左右两边继续处理。 具体做的时候，就对笛卡尔树进⾏dfs，同时记录⼀下左边这段区间已经摆放的梯⼦⾼度和右边区间摆放的梯⼦⾼度。如果左边区间梯子高度是$H_l$，并且当前节点的⾼度是$h_v$，左儿子的节点⾼度是 ，那么如果$H_l=Hu$，意味着我们可以直接从当前梯子高度⾛过来，否则我们要新建⼀段从$u$到$v$⾼度为$H_u$的梯⼦。 时间复杂度$O(n)$。 笛卡尔树 先找到一个最小值，然后再在左右两边分治。 变换30分做法枚举$k = 1,2,…,m$，将小于$k$的当成$-1$，等于$k$的当$1$，⼤于$k$的当成$1$，跑状压dp即可，可能要使⽤BFS。 60分做法每两个 之间的都是独⽴的，所以我们思考⼀下每段需要多少步。 我们可以从两头开始依次把每个出变成$0$，比如⼀端是 0 1 1 这样，那么可以使⽤⼀次 操作将其变成 0 0 1 ，如果⼀端是 0 -1 1 的时候，那么我们只能先使⽤ 操作将其变成 0 1 1 ，然后接着操作。也就是如果有 -1 和 1 间隔，那么会额外进⾏⼀次操作，我们想让额外的操作次数尽量⼩。同时我们发现，如果有间隔的 1 -1 1 ，那么可以⽤⼀次$\max$操作将其变成 1 1 1 。 经过归纳总结⼀下，可以将序列划分成若⼲段极⻓的 1 与 -1 间隔的段，每段需要的额外的操作代价是⻓度除以$2$下取整。 100分做法序列相当于被划分成了若⼲段，当且仅当两个数如果⾄少有⼀个是$0$或者两个数相同，那么会被划分开来。然后总代价是每段⻓度除以$2$下取整加上所有非$0$的数，所以当 从⼩到⼤变化的时候，我们⽤⼀个set维护⼀下每段的变化即可。 第三题40分做法状压dp即可。 100分做法容易发现，Bob必胜的充要条件是存在完备匹配，由于这是⼀棵树，那么可以贪⼼地搞这个匹配。 令$dp(i,j)$表示$i$这个⼦树会有$j$个点没有被匹配，然后转移的时候就把⼦树所有没有被匹配的点加起来，选了$i$这个点，如果⼦树⾥⾯存在没有被匹配的点，那么没有被匹配的点会减$1$，否则会加$1$。 时间复杂度$O(n^2)$。]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[正睿Day5题解]]></title>
    <url>%2F2019%2F10%2F22%2F%E6%AD%A3%E7%9D%BFDay5%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[点击下载题目 color 我们可以把染黑看成删掉这条边，那么每次相当于是，如果存在一个点有且仅有一条出边，那么把这条边也删掉，最后要删完所有的边。那么我们考虑一个环，可以发现这个环如果一条边都不删，那么最后一定会被留下来，因为每个点都至少有两个出边。所以，在初始的边删完之后，图一定得要无环。我们考虑一个无环的图，可以发现他就是一个森林。考虑森林的叶子节点，可以发现每次叶子节点的父边都会被删掉，而删掉之后森林还是森林。因此，在有限步操作之后，所有的边都会被删掉，所以无环就一定合法了。因此我们最后的答案就是，给每个联通块都保留一个生成树，其他边全都删掉。考虑这个东西怎么算。因为一棵生成树的边数是点数减一，所有联通块的总点数是 n，所以如果设联通块数为 C，则最后剩下的边个数就是 n - C，因此答案就是$m - n + C$。时间复杂度： $Θ(nα(n) + m)$ 其实就dfs出一棵树然后统计dfs树之外有多少边没有被遍历好了…… code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;int n,m,x,y,ans,cnt,d[100005],du[100005],vis[100005];struct edge&#123; int to,nex,del,fro;&#125;e[500005];struct node&#123; int u,du; bool operator &lt; (const node &amp;x) const &#123;return x.du &lt; du;&#125;&#125;;void add(int x,int y)&#123; e[++cnt].to = y; e[cnt].fro = x; e[cnt].nex = d[x]; d[x] = cnt;&#125;int E(int x)&#123; if(x &amp; 1) return x + 1; return x - 1;&#125;void dfs(int u)&#123; vis[u] = 1; for(int i = d[u]; i; i = e[i].nex) &#123; if(vis[e[i].to]) continue; ans++; vis[e[i].to] = 1; dfs(e[i].to); &#125;&#125;int main()&#123; n = read(); m = read(); for(int i = 1; i &lt;= m; i++) &#123; x = read(); y = read(); add(x,y); add(y,x); du[x]++; du[y]++; &#125; for(int i = 1; i &lt;= n; i++) if(!vis[i]) dfs(i); printf("%d\n",m - ans); return 0;&#125; power 考虑二分答案，则问题变为了求 [1, M] 内有多少个数字在至少一个 S(ni) 里面。考虑容斥：我们考虑先计算出有多少个 [1, M] 中的数在 S(n1), S(n2), · · · , S(nk)中，然后把它们都加起来。显然这样算多了：如果某个数字同时在多个 S(ni) 里面，那么他就重复了。于是我们考虑再去掉在至少两个 S(ni) 中的，然后加上至少三个 S(ni) 中的，去掉至少四个 S(ni) 中的……那么我们现在相当于是需要考虑一个 {n1, n2, · · · , nk} 的子集 N，计算有多少个数字 x ∈ [1, M]，满足 ∀t ∈ N，有 x ∈ (t)。可以发现， ∪t∈NS(t) = S(lcmt∈N(t))，因此可以直接二分得到这样的 x 个数。直接枚举 S 进行计算的时间复杂度为 Θ(q · 2k · log2 2 M)，可以通过子任务 3。注意到我们最终的答案只与 lcmt∈N(t) 有关，因此我们可以考虑 DP：设 fi,t 表示考虑 n1, n2, · · · , ni，从中选出一个子集，满足他们的 lcm 是 t 的容斥系数之和。注意到当 lcmt∈N(t) ≥ 60 时，一定不存在这样的 x（因为答案不超过 1017，所以M ≤ 1017）。于是在 DP 的第二个维度只保留不超过 60 的那些值即可。时间复杂度： Θ(q(k log2 M + log3 2 M))。 bitop 3.1 按位与我们按照从高位到低位的顺序进行贪心，如果当前位有至少两个数字是 1，那么我们可以让这一位是 1，因此最终答案的这一位一定是 1。那么如果我们确定了某一位是 1，我们最后选择的两个数的这一位都得是 1，所以我们可以去掉所有这一位为 0 的数字，然后继续向下贪心即可。最后的方案数就是剩余的数字中选出两个的方案数。时间复杂度： Θ(n log2 ai)。3.2 按位异或同样地从高到低贪心，逐位确定。但是直接确定下来某一位是 1 并不能和按位与那样减少候选范围。考虑先确定最后选择的一个数字 ai，考虑如何求出另一个 aj 使得 ai xor aj 最大。考虑将所有数字建出一个 trie 树，然后同样从高到低进行贪心：如果当前位可以取得和 ai 这一位不一样，那么就取不一样的，否则取一样的。方案数可以在 trie 树的每个节点上存储对应数字个数得到。时间复杂度： Θ(n log2 ai)。3.3 按位或同样地在确定了一个数之后从高到低贪心。但是这里又多了一个问题：如果这个数字的当前位是 1，那么我们仍然没法减少候选范围。那么在贪心到某一步之后，相当于是给定一个位的集合 S，判断是否一个数的这些位都是 1，其余位不管。接下来我们用 Ai 表示数字 ai 中 1 的位置集合。考虑 DP（事实上，这个 DP 方法叫做高维前缀和）：设 fi,S 表示使得 S ⊆ At 且At \ S ⊆ {1, 2, · · · , i} 的 t 的个数。那么转移时，考虑 at 的当前位是 0 还是 1，然后可以变成 fi-1,S 以及 fi-1,S{i} 两种，直接相加即可。那么我们就可以判断是否存在一个合法的数字了。最后的方案数同样可以使用这个 DP 数组求出。时间复杂度： Θ(ai log2 ai)。]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019正睿Day4题解]]></title>
    <url>%2F2019%2F10%2F21%2F2019%E6%AD%A3%E7%9D%BFDay4%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[下载题目 path考虑直接在 DFS 整棵树的过程中构造哈密尔顿回路。 先考虑如果是一条链怎么构造，我们可以隔一个跳一下，就像这样： 那么这样构造我们只需要用到距离不超过 2 的边，所以直接拓展到树上即可：如果当前节点深度是奇数，那么我们在 DFS 前输出这个点，否则在 DFS 完所有孩子之后再输出这个点。容易验证这样构造是对的。 时间复杂度： $Θ(n)$。 magic首先，使用 KMP 算法对于每个 Ti，求出它在 S 中的匹配位置，那么这些位置中至少得要挖掉一个。 于是对于每个 i，我们可以求出一个 Li，表示 [Li, i] 之间必须要挖掉至少一个。 然后我们考虑 DP，设 fi 表示最后一个挖掉的位置是 i 的最小代价，那么转移时枚举上一个挖掉的位置即可做到时间复杂度 $Θ(n^2)$。 考虑优化。注意到我们在转移时一定是整体转移，而每次可能非法化一个前缀。因此，如果我们不再进行非法化，那么可以转移的区间就是原序列的一个后缀，因此我们可以变为后缀查询最小值、单点修改。直接使用树状数组维护即可。 时间复杂度： $Θ (nlog_2n+∑_{i=1}^m(|S| + |Ti|))$。 inter可以发现 u, v 是独立的。我们等价于要求：在 u 的子树中选 k 个点使它们两两LCA 是 u 的方案数，对 v 也求同样的东西，再把两者相乘就是最后的答案了。 如果 u, v 存在祖孙关系，不妨设 u 是 v 的祖先，那么 u 的子树就要改为以 v 的方向作为根方向前提下的子树。 显然为了使两两 LCA 是 u，在 u 的每一个儿子中就至多只能选一个点。于是我们做一个背包，就可以得到以 u 作为根的时候选择 k ≤ L 个点的方案数，然后选择 u的方案直接枚举 u 被选了多少次，做一个组合数即可。 但是我们这样求出的是以 u 为根的方案数，其中可能会有的点选在了 u → v 的方向上，这样就不满足条件了。 考虑这个背包的实质，可以发现他求的是下列生成函数的 xk 项的系数： 那么我们现在要求的是不在 v 方向的多项式 Pu,v(x)，他的式子如下： 则可以发现 Pu,v(x) 就是 Pu(x) 除掉一个 (1 + sizew · x) 之后的结果，其中 w 是u 在 v 方向的出边。可以发现，多项式除以单项式其实就是背包的过程倒过来，直接做就可以做到线性复杂度。 时间复杂度： $Θ((n + q)L + qk)$。]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[题解 P1951 【收费站_NOI导刊2009提高（2）】]]></title>
    <url>%2F2019%2F10%2F19%2F%E9%A2%98%E8%A7%A3-P1951-%E3%80%90%E6%94%B6%E8%B4%B9%E7%AB%99-NOI%E5%AF%BC%E5%88%8A2009%E6%8F%90%E9%AB%98%EF%BC%882%EF%BC%89%E3%80%91%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 核心思路题目让求最大费用的最小值，很显然这道题可以二分，于是我们可以二分花费的最大值。 check函数那么，我们该怎么写check函数呢？ 我们可以删去费用大于mid的点以及与其相连的边，然后在剩余的点和边组成的图上跑一遍最短路求出从u到v需要消耗的最小的汽油，如果消耗汽油最小值不大于s，那么返回true，否则返回false。 注意事项 在二分时一定要判断到起点的花费是否大于mid r的初始值值应为$f_{max}+1$,因为如果$r_{start}=f_{max}$,那么$mid=(l+2)&gt;&gt;1$恒小于$f_{max}$，即你永远不会尝试取走花费最大的点。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define ll long long#define INF 1000000000#define re registerusing namespace std;long long read()&#123; register long long x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;long long n,m,u,v,s,ans,x,y,z,l,r,mid,cnt,flag,f[100005],d[100005],dis[100005],vis[100005];struct edge&#123; long long to,nex,w;&#125;e[1000005];struct node&#123; long long k,dis; bool operator &lt; (const node &amp;x) const&#123;return x.dis &lt; dis;&#125;&#125;;void add(long long x,long long y,long long z)&#123; e[++cnt].to = y; e[cnt].nex = d[x]; e[cnt].w = z; d[x] = cnt;&#125;priority_queue&lt;node&gt; que;void dij()&#123; while(!que.empty()) que.pop(); que.push((node)&#123;u,0&#125;); while(!que.empty()) &#123; node u = que.top(); que.pop(); if(vis[u.k]) continue; vis[u.k] = 1; if(f[u.k] &gt; mid) continue; for(register int i = d[u.k]; i; i = e[i].nex) &#123; if(f[e[i].to] &gt; mid) continue; if(dis[e[i].to] &gt; dis[u.k] + e[i].w) &#123; dis[e[i].to] = e[i].w + dis[u.k]; if(!vis[e[i].to]) que.push((node)&#123;e[i].to,dis[e[i].to]&#125;); &#125; &#125; &#125;&#125; bool check(long long Max)&#123; if(f[u] &gt; Max || f[v] &gt; Max) return false; memset(dis,0x7f,sizeof(dis)); memset(vis,0,sizeof(vis)); dis[u] = 0; dij(); if(dis[v] &lt;= s) flag = 1; if(dis[v] &lt;= s) return true; return false;&#125;struct EDGE&#123; long long x,y,z;&#125;E[1000005];bool cmp(EDGE a, EDGE b)&#123; if(a.x != b.x) return a.x &lt; b.x; if(a.y != b.y) return a.y &lt; b.y; return a.z &lt; b.z;&#125;int main()&#123; n = read(); m = read(); u = read(); v = read(); s = read(); for(int i = 1; i &lt;= n; i++) f[i] = read(),r = max(r,f[i]); r++; for(int i = 1; i &lt;= m; i++) &#123; E[i].x = read(); E[i].y = read(); E[i].z = read(); &#125; sort(E + 1, E + m + 1, cmp); for(int i = 1; i &lt;= m; i++) if((E[i].x != E[i - 1].x || E[i].y != E[i - 1].y) &amp;&amp; E[i].x != E[i].y) add(E[i].x,E[i].y,E[i].z),add(E[i].y,E[i].x,E[i].z); while(l &lt; r) &#123; mid = (l + r) &gt;&gt; 1; if(check(mid)) r = mid; else l = mid + 1; &#125; if(flag == 0) printf("-1\n"); else printf("%lld\n",r); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019正睿Day3题解]]></title>
    <url>%2F2019%2F10%2F19%2F2019%E6%AD%A3%E7%9D%BFDay3%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[https://download.csdn.net/download/qq_45721135/11869621 T1 大小关系相同的一个区间填的数是一段连续的数 每一段数用卡特兰数求解 证明： 钩子公式 杨氏图表 T2]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019正睿Day2题解]]></title>
    <url>%2F2019%2F10%2F19%2F2019%E6%AD%A3%E7%9D%BFDay2%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[https://download.csdn.net/download/qq_45721135/11866498 1.stone 根据期望的线性性，答案 E(t) = P2 + P3 + · · · + Pn + 1，其中 Pi 是第 i 堆石子在第 1 堆之前被取走的概率。考虑第 i 堆，可以发现其他堆都不会影响这两堆，因此相当于只要考虑只有这两堆的情况，因此概率即为$\frac{ai}{a1 + ai}$。因此答案即为$\sum_{i=2}^{n}{\frac{ai}{a1 + ai}+1}$，直接计算即可。时间复杂度： Θ(n)。 2.memory 对于每个 x，考虑如果用它来压缩那么可以达到的最优解，设为 F(x)。假如给定一个 x，想要求 F(x)，那么可以通过二分贪心在 Θ(n log2 n) 的时间内算出。直接对于所有 x 都暴力计算即可得到 Θ(nm log2 n) 的复杂度，可以通过子任务1, 2。如果我们以随机顺序遍历所有 x，则在期望情况下，新的 F(x) 比当前所有F 的值都要小的 x 个数的期望应该是 ∑ 1/i，这是调和级数，为 Θ(ln n)。于是我们只对于这些 x 二分即可：我们令答案为 ans − 1 并贪心，即可判断当前的 x 是否满足条件。时间复杂度： Θ(nm + n ln n log2 n)。 使最大值最小，很显然这是一个二分。 60分做法这个部分分还是非常好拿的，只需要枚举每一个x并二分求答案即可。 时间复杂度：$O(nmlogn)$ 100分做法其实就是再60分做法的基础上做一个类似与搜索的最优化剪枝的优化。 我们可以发现，当我们枚举到一个x的时候，当且仅当在$a[i]=(a[i]+x)%m$的基础上check(ans-1)成立（ans为区间[1,x-1]求得的最小值），这个x才有可能对答案产生贡献，所以我们在每次二分前根据check(ans-1)的情况去决定是否对x进行二分答案即可。 注意，为了防止自己被卡，最好将x的枚举顺序打乱后再进行枚举。 code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re register#define rep(i,a,b) for(int i = (a); i &lt;= (b); i++)#define qwq printf("qwq\n");using namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;int n,m,k,l,r,ti,mid,ans,sum,a[100005],b[100005],c[100005];bool check(int l)&#123; int cnt = 1; sum = 0; for(int i = 1; i &lt;= n; i++) &#123; if(sum + b[i] &gt; l) cnt++,sum = 0; sum += b[i]; if(cnt &gt; k) return false; &#125; return true;&#125;int cmp(int a,int b) &#123;return rand() % 2;&#125;int main()&#123; n = read(); m = read(); k = read(); srand(time(0)); for(int i = 1; i &lt; m; i++) c[i] = i; sort(c + 1, c + m,cmp); for(int i = 1; i &lt;= n; i++) a[i] = read(); ans = INF; for(int i = 1; i &lt; m; i++) &#123; int y = c[i]; l = 0; for(int j = 1; j &lt;= n; j++) b[j] = (a[j] + y) % m,sum += b[j],l = max(l,b[j]); r = min(ans,sum); while(l &lt; r) &#123; mid = (l + r) &gt;&gt; 1; if(check(mid)) r = mid,ans = min(ans,r); else l = mid + 1; &#125; &#125; printf("%d\n",ans); return 0;&#125; 3.subset 显然我们只会选择 n 的约数，因为如果选了其他的那么最小公倍数一定不是 n。考虑对 n 进行分解，设 n = pα 1 1pα 2 2 · · · pα kk。那么我们要求选的数字满足：对于每个 i ∈ [1, k]，均存在一个数在 pi 中是 0 次方，也存在一个数在 pi 中是 αi 次方。直接计算并不容易，考虑容斥原理：如果只有一个 pα，那么我们用所有情况去掉不存在 0 次方的情况，再去掉不存在 α 次方的情况，然后加上都不存在的情况即可。然后对于原问题，我们可以 Θ(4k) 枚举每个质因数是上面四种情况中的哪一种，然后计算出这种情况下的方案数即可。时间复杂度： Θ(4ω(n)ω(n))，可以通过子任务1, 2。考虑如何进行优化。注意到对于第一种情况，方案数为 (αi + 1)，第二种和第三种情况都是 αi，而第四种是 (αi − 1)。因此，我们可以转而枚举方案数的可能性，这只有三种，因此枚举的复杂度从 Θ(4k) 降到了 Θ(3k)。值得一提的是，这里对 n 进行分解是本题的难点： Θ(√n) 的复杂度并不可以接受，但我们并不需要真的得到 p1, p2, · · · , pk，而是只要知道 α1, α2, · · · , αk 即可。我们考虑先分解出所有 pi ≤ √3 n 的 pα i i，那么剩余部分只有 p, p2, pq 三种，其中p, q 都是质数。那么我们先使用 Miller Rabin 算法判断 p 的情况，然后开根号后平方判断 p2 的情况，剩余的情况就是 pq 的情况了。时间复杂度： Θ(√3 n + 3ω(n)ω(n))。]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019正睿Day1题解]]></title>
    <url>%2F2019%2F10%2F19%2F2019%E6%AD%A3%E7%9D%BFDay1%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[https://download.csdn.net/download/qq_45721135/11866474 1.seq 奇数和偶数显然是独立的，我们只考虑其中一种即可。如果没有要求字典序最小的话，则显然相对位置不变的方案是最优的，那么我们可以直接得到一种合法方案以及最小代价。我们用 xi 表示第 i 个数是往左，往右还是不变，那么按 xi 分段后显然每一段是独立的，否则代价一定大了。那么我们考虑 xi 相同的一段。如果他们都是向左的，那么我们可以按照从大到小的顺序，每个数字都尽可能向后面放。而如果都是向右的，我们按照从小到大的顺序每个数字都尽可能往前面放即可。可以发现，这样的两种放法都可以最小化字典序，因此都是对的。时间复杂度： Θ(n log2 n)。 2.bulb 考虑建出一张图，他的点就是原来的灯泡 1, 2, · · · , n。然后如果 i 和 i + 1 都是亮着的，那么就把他们之间连一条边。那么一个极长亮灯区间就对应图中的一个联通块。因为链也是树，所以连通块数等于点数减边数，即极长亮灯区间数等于亮着的灯泡数减去连续亮着的灯泡数。前者显然可以非常方便地维护，考虑如何维护这个连续亮着的灯泡数。设阈值 B，则我们可以把所有颜色按照对应灯泡个数和 B 的关系分为大小两种。若翻转的是小的颜色，则我们直接可以暴力枚举这种颜色中的所有点，然后计算连续亮着的灯泡数。否则如果翻转的是大的颜色，则和它相邻的颜色有两种：小的和大的：• 如果是大的，那么因为大的颜色只有 Bn 种，所以只要先预处理出任意两种大的颜色之间有多少条边可以连，然后直接枚举这个另外的大的颜色即可。• 对于小的的情况，我们考虑在小的那里处理。即，在枚举小的点的时候，如果周围遇到了一个大的颜色，则我们就在这个大的颜色上打一个标记，表示如果它翻转了那么会造成多大的改变即可。时间复杂度： Θ(q(B + Bn ))，取 B = √n 即可做到时间复杂度 Θ(q√n)。 3.match 显然对于某个 k，若存在这样的 k 个人，那么必定唯一。这是因为我们如果存在某两个合法集合 S 以及 T，一定存在 u ∈ S 而 u ̸∈ T 以及 v ∈ T 而 v ̸∈ S。根据合法集合的定义，我们从 S 的定义可得 u 胜过 v，而从 T的定义可得 v 胜过 u，矛盾。因此这样的集合一定唯一。设 Fn,k 表示 n 个人中存在这样 k 个人的概率，考虑转移。考虑如何计算 Fn+1,k，如果 n+ 1 在集合外，那么他一定要输给前面的这 k 个人，而这 k 个人的编号都比他小，因此概率为 pk。如果他在集合内，那么他要赢前面的n − k + 1 个人，因此概率为 qn−k+1，其中 q = 1 − p。因此，我们有Fn+1,k = Fn,k · pk + Fn,k−1 · qn−k+1同时，我们也可以通过考虑 1 这个人来做出转移。如果 1 在集合外，那么他要输给后面的这 k 个人，而这 k 个人的编号都比他大，因此概率为 qk。如果他在集合内，那么他要赢后面的 n − k + 1 个人，因此概率为 pn−k+1。因此，我们又有Fn+1,k = Fn,k · qk + Fn,k−1 · pn−k+1所以，我们有Fn,k · pk + Fn,k−1 · qn−k+1 = Fn,k · qk + Fn,k−1 · pn−k+1也就是说，Fn,k · (pk − qk) = Fn,k−1 · (pn−k+1 − qn−k+1)此外 Fn,0 = 1，所以如果 p ̸= q，即 p ̸= 1/2，我们就可以在 Θ(n) 的时间内算出所有的 Fn,k，从而得到答案。而剩下的情况是 p = q，则此时和下标无关，任意两个人之间一个人胜利的概率都是 1/2。因此，我们考虑选出 k 个人作为最后的胜者，则有Fn,k = (nk) · 2k(n1−k)两种情况的时间复杂度都是 Θ(n) 或 Θ(n log2 n)。]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[STL-vector]]></title>
    <url>%2F2019%2F10%2F19%2FSTL-vector%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334#include&lt;vector&gt;vector&lt;int&gt; vec;vector &lt;int&gt; vec(10,1);//创建了有10个元素的向量，并赋初值为1int b[7]=&#123;1,2,3,4,5,9,8&#125;; vector&lt;int&gt; a(b,b+7);//push_back(尾部插入一个元素)vec.push_back(a); //insert(插入一个元素)vec.insert(position,elem) //在pos位置插入一个elem拷贝，传回新数据位置。vec.insert(position,n,elem) //在pos位置插入n个elem数据，无返回值。vec.insert(position,begin,end) //在pos位置插入在[beg,end)区间的数据，无返回值。//erase(删除指定位置的元素)vec.erase(iterator it);//[]访问，由于vector重载了[]，所以可以利用[]直接访问已有元素cout &lt;&lt; vec[1];//at(返回指定位置的元素)vec.at(1);//at()函数具有检测是否越界的功能，如果越界会抛出错误，所以安全性高于[] //迭代器访问vector &lt;int&gt; vec;vector &lt;int&gt;::iterator it;for (it = vec.begin(); it != vec.end(); it++) cout &lt;&lt; *it;//vec.clear();//清空//vec.back(),vec.front(),vec.empty()//返回末尾，返回头，判断是否为空 //vec.begin(),vec.end()//传回对应位置的迭代器 //vector作为容器，可以使用较多algorithm中的函数，例如sort，reverse，swap。]]></content>
      <categories>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解题报告-2019国庆清北Day6]]></title>
    <url>%2F2019%2F10%2F19%2F%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A-2019%E5%9B%BD%E5%BA%86%E6%B8%85%E5%8C%97Day6%2F</url>
    <content type="text"><![CDATA[https://download.csdn.net/download/qq_45721135/11866514 Day6T1二维差分 考场代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define INF 0x7fffffffusing namespace std;int n,m,k,ux,dx,lx,rx,ans,cnt,sum;int map[1000005],u[1000005],d[1000005],l[1000005],r[1000005],tj[1000005];int cx[1000005],f[1000005];int main()&#123; freopen("paint.in","r",stdin); freopen("paint.out","w",stdout); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i = 1; i &lt;= k; i++) u[i] = l[i] = INF,d[i] = r[i] = 0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) &#123; cnt++; scanf("%d",&amp;map[cnt]); cx[map[cnt]] = 1; u[map[cnt]] = min(u[map[cnt]],i); d[map[cnt]] = max(d[map[cnt]],i); l[map[cnt]] = min(l[map[cnt]],j); r[map[cnt]] = max(r[map[cnt]],j); &#125; for(int i = 1; i &lt;= k; i++) &#123; if(!cx[i]) continue; f[u[i] * m - m + l[i]]++; f[u[i] * m - m + r[i] + 1]--; f[d[i] * m + l[i]]--; f[d[i] * m + r[i] + 1]++; &#125;// printf("%d %d %d %d\n",u[2],d[2],l[2],r[2]);// f[u[2] * m - m + l[2]]++;// f[u[2] * m - m + r[2] + 1]--;// f[d[2] * m + l[2]]--;// f[d[2] * m + r[2] + 1]++;// for(int i = 1; i &lt;= n; i++)// &#123;// for(int j = 1; j &lt;= m; j++) printf("%d ",f[i * m - m + j]);// printf("\n");// &#125; for(int i = 1; i &lt;= n; i++) f[i] = f[i - 1] + f[i]; for(int i = 2; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) f[i*m-m+j] = f[i*m-m-m+j] + f[i*m-m+j-1] - f[i*m-m-m+j-1] + f[i*m-m+j];// for(int i = 1; i &lt;= n; i++)// &#123;// for(int j = 1; j &lt;= m; j++) printf("%d ",f[i * m - m + j]);// printf("\n");// &#125; for(int i = 1; i &lt;= cnt; i++) if(f[i] &gt; 1) tj[map[i]] = 1; for(int i = 1; i &lt;= k; i++) if(!tj[i]) ans++; for(int i = 1; i &lt;= k; i++) if(cx[i]) sum++; if(sum == 1 &amp;&amp; k &gt; 1) ans--; printf("%d\n",ans); fclose(stdin); fclose(stdout); return 0;&#125; std然而std和我的算法貌似不一样…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt; #define M 100010#define p(a, b) (a * mm + b - mm) using namespace std;int i, j, Li[M], Ri[M], Lj[M], Rj[M], a[M], use[M], ans, n, m, K, fl, nxt[M], pre[M], vis[M], mm, u;int find(int x)&#123; if(!vis[x])return x; return nxt[x] = find(nxt[x]);&#125;int main()&#123; fl = 0; scanf("%d%d%d", &amp;n, &amp;m, &amp;K); memset(Li, 63, sizeof(Li)); memset(Lj, 63, sizeof(Lj)); memset(Ri, 0, sizeof(Ri)); memset(Rj, 0, sizeof(Rj)); memset(use, 0, sizeof(use)); mm = max(n, m); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++)&#123; if(n &gt; m) u = p(j, i); else u = p(i, j); scanf("%d", &amp;a[u]); &#125; if(n &gt; m)swap(n, m); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++)&#123; u = p(i, j); nxt[u] = p(i, j + 1); pre[u] = p(i, j - 1); if(Ri[a[u]] == 0 &amp;&amp; a[u])fl++; if(i &lt; Li[a[u]])Li[a[u]] = i; if(i &gt; Ri[a[u]])Ri[a[u]] = i; if(j &lt; Lj[a[u]])Lj[a[u]] = j; if(j &gt; Rj[a[u]])Rj[a[u]] = j; &#125; for(int i = 1; i &lt;= K; i++) if(Li[i] &lt;= Ri[i])&#123; for(int j = Li[i]; j &lt;= Ri[i]; j++) for(int k = Lj[i]; k &lt;= Rj[i]; k = find(nxt[k])) if(a[p(j, k)] != i)&#123; use[a[p(j, k)]] = 1; vis[p(j, k)] = 1; nxt[pre[p(j, k)]] = nxt[p(j, k)]; pre[nxt[p(j, k)]] = pre[p(j, k)]; &#125; &#125; for(int i = 1; i &lt;= K; i++) if(!use[i])ans++; if(ans == K &amp;&amp; fl == 1 &amp;&amp; ans &gt; 1)ans--; if(fl)printf("%d\n", ans); else puts("0");&#125; T2 std123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;#define N 1000010using namespace std;map&lt;int, int&gt;dad, h;int n, m, l, r, X, Y, i, t, k, p;char s1[110];int find(int x)&#123; if(!dad[x])return x; int t = find(dad[x]); h[x] = (h[x] + h[dad[x]]) % p; return dad[x] = t;&#125;char ch;void read(int &amp;x) &#123; for(ch = getchar(); ch &lt; '0'; ch = getchar()); for(x = 0; ch &gt;= '0'; ch = getchar()) x = x * 10 + ch - '0';&#125;int main()&#123; read(n); read(m); read(p); for(i = 1; i &lt;= m; i++)&#123; read(l); read(r); read(k); r++; X = find(l); Y = find(r); t = (h[r] - h[l] + p) % p; if(X != Y)&#123; dad[X] = Y; h[X] = (t - k + p) % p; &#125;else if(t != k)break; &#125; printf("%d\n", i - 1);&#125; T3std1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define N 1000010using namespace std;int n, a[N], f[N], g[N], F[N], G[N], t, ans;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); sort(a + 1, a + n + 1); F[1] = 1, f[0] = 0; for(int i = 2; i &lt;= n; i++)&#123; f[i] = 5e8; for(F[i] = F[i - 1]; (a[i] - a[F[i] + 1]) * 2 &gt;= f[F[i] + 1] * 3; F[i]++); f[i] = min((f[F[i] + 1] * 3 + 1) / 2, a[i] - a[F[i]]); &#125; G[n] = n, g[n] = 0; for(int i = n - 1; i &gt;= 1; i--)&#123; g[i] = 5e8; for(G[i] = G[i + 1]; (a[G[i] - 1] - a[i]) * 2 &gt;= g[G[i] - 1] * 3; G[i]--); g[i] = min((g[G[i] - 1] * 3 + 1) / 2, a[G[i]] - a[i]); &#125; ans = 2e9; for(int i = 1; i &lt;= n; i++)&#123; if(max(f[i], g[i]) &lt; ans) t = i; ans = min(ans, max(f[i], g[i])); &#125; int tt = t, an = ans; for(int j = t; j &gt;= 1; j--)&#123; if(a[j] &lt; a[tt] - an)&#123; tt = j + 1; an = an * 3 / 2; &#125; if(a[j] &lt; a[tt] - an)assert(1); &#125; tt = t, an = ans; for(int j = t; j &lt;= n; j++)&#123; if(a[j] &gt; a[tt] + an)&#123; tt = j - 1; an = an * 3 / 2; &#125; if(a[j] &gt; a[tt] + an)assert(2); &#125; tt = t, an = ans - 1; int flag = 0; for(int j = t; j &gt;= 1; j--)&#123; if(a[j] &lt; a[tt] - an)&#123; tt = j + 1; an = an * 3 / 2; &#125; if(a[j] &lt; a[tt] - an)flag = 1; &#125; if(!flag)assert(3); tt = t, an = ans - 1; flag = 0; for(int j = t; j &lt;= n; j++)&#123; if(a[j] &gt; a[tt] + an)&#123; tt = j - 1; an = an * 3 / 2; &#125; if(a[j] &gt; a[tt] + an)flag = 1; &#125; if(!flag)assert(4); printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解题报告-2019国庆清北Day5]]></title>
    <url>%2F2019%2F10%2F19%2F%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A-2019%E5%9B%BD%E5%BA%86%E6%B8%85%E5%8C%97Day5%2F</url>
    <content type="text"><![CDATA[https://download.csdn.net/download/qq_45721135/11866519 Day5最小差异矩阵（a.cpp, a.in, a.out）题面【题目描述】 有一个 n*m 的矩阵，矩阵的每个位置上可以放置一个数。对于第 i 行，第 i 行的差异定 义为该行的最大数和最小数的差。一个矩阵的差异，定义为矩阵中每一行差异的最大值。现 在给定 k 个数 v[1..k]，问：从这 k 个数中选 n*m 个数放入矩阵，能够得到的矩阵的差异最 小值是多少。 【输入格式】 第一行三个整数，k, n, m，表示有 k 个数可选，矩阵的行数和列数分别为 n 和 m。 第二行 k 个整数，表示备选的数 v[1..k]。 【输出格式】 输出一个数，表示能够得到的最小差异值 【样例输入】 5 2 2 7 5 8 2 3 【样例输出】 1 【数据范围】 对于 30%的数据，k&lt;= 10, n &lt;= 3, m &lt;= 3 对于 100%的数据，n * m &lt;= k &lt;= 100000, n, m &lt;= 1000，0&lt;= v[i] &lt;= 10^9 【时空限制】 256MB，1s 考场思路仔细读题，就发现这道题目是要让最大值最小，于是貌似就可以去二分答案。可以发现，如果把所有可以填的数排一下序，那么最优方法中每一行所选的数在排好序的序列中一定是连续的，所以可以贪心去取每一行的数，来验证答案。 考场代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re register#define rep(i,a,b) for(int i = (a); i &lt;= (b); i++)#define qwq printf("qwq\n");using namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;int n,m,k,l,r,mid,ans,a[100005];int cmp(int x,int y)&#123;return x &lt; y;&#125;int check(int v)&#123; int p1 = 0,p2 = 0,cnt = 1; while(cnt &lt;= n) &#123; p1 = p2 = p2 + 1; while(p2 - p1 + 1 &lt; m) &#123; p2++; if(p2 &gt; k) return 0; while(a[p2] - a[p1] &gt; v) p1++; &#125; cnt++; &#125; return 1;&#125;int main()&#123; freopen("a.in","r",stdin); freopen("a.out","w",stdout); k = read(); n = read(); m = read(); for(int i = 1; i &lt;= k; i++) a[i] = read(),r = max(r,a[i]); sort(a + 1, a + k + 1,cmp); while(l &lt; r) &#123; mid = (l + r) &gt;&gt; 1 if(check(mid)) r = mid,ans = mid; else l = mid + 1; &#125; printf("%d\n",ans); fclose(stdin); fclose(stdout); return 0;&#125; 题解 std1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 7;int n, m, k, v[maxn];int judge(int d)&#123; int tmp = 0; for (int i=1; i+m-1&lt;=k; ++i) &#123; if (v[i+m-1] - v[i] &lt;=d) ++tmp, i += m - 1; &#125; if (tmp &gt;= n) return 1; return 0;&#125;int main()&#123; freopen("a.in", "r", stdin); freopen("a.out", "w", stdout); scanf("%d%d%d", &amp;k, &amp;n, &amp;m); for (int i=1; i&lt;=k; ++i) scanf("%d", &amp;v[i]); sort(v + 1, v + k + 1); int left = 0, right = 1e9; while (left &lt; right) &#123; int mid = (left + right) / 2; if (judge(mid)) right = mid; else left = mid + 1; &#125; printf("%d\n", left); return 0;&#125; 分割序列（b.cpp, b.in, b.out）【题目描述】 给定一个长度为 n 的序列 v[1..n]，现在要将这个序列分成 k 段（每段都丌能为空），定 义每一段的权值为该段上的所有数的戒和。定义整个序列的权值为每段权值的和。问：这个 序列的最大权值为多少。 【输入格式】 第一行两个数 n 和 k，意义如题意所示。 第二行 n 个数，表示这个序列 v[1..n]。 【输出格式】 输出一个数，代表这个序列的最大权值。 【输入样例】 5 2 7 5 8 2 3 【输出样例】 22 【数据范围】 对于 30%的数据，n&lt;= 10, k &lt;= 10 对于 60%的数据，n &lt;= 100, k &lt;= 100 对于 100%的数据，k &lt;= n &lt;= 2000，1&lt;= v[i] &lt;= 5 * 10^5 【时空限制】 256MB，1s 考场思路一看到题就感觉像是个DP，于是就敲了一个$O(n^3)$的暴力。 状态设计：用$f[i][j]$表示把区间1~i分成j段能获得的最大价值。转移：$f[i][j]=\max(f[k][j-1]+l[k+1][i]) $，其中$l[i][j]$表示对区间[i,j]按位或的结果。 考场代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re register#define rep(i,a,b) for(int i = (a); i &lt;= (b); i++)#define qwq printf("qwq\n");using namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;long long n,k,v[100005],l[2005][2005],f[2005][2005];int main()&#123; freopen("b.in","r",stdin); freopen("b.out","w",stdout); n = read(); k = read(); for(int i = 1; i &lt;= n; i++) l[i][i] = read(); for(int i = 1; i &lt;= n; i++) for(int j = i + 1; j &lt;= n; j++) l[i][j] = l[i][j - 1] | l[j][j]; for(int i = 1; i &lt;= n; i++) f[i][1] = l[1][i]; for(int i = 1; i &lt;= n; i++) for(int j = 2; j &lt;= k; j++) &#123; if(j &gt; i) break; for(int m = 1; m &lt; i; m++) f[i][j] = max(f[i][j],f[m][j - 1] + l[m + 1][i]); &#125; printf("%lld\n",f[n][k]); fclose(stdin); fclose(stdout); return 0;&#125; 题解 考虑用单调性去优化dp的复杂度。 $l[i][j]$j不变，关于i单调递减 std123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const long long inf = 1ull &lt;&lt; 30 &lt;&lt; 20;const int maxn = 2005;vector&lt;int&gt; point[maxn];int n, K, v[maxn], sum[maxn][maxn];long long f[maxn][maxn];int main()&#123; freopen("b.in", "r", stdin); freopen("b.out", "w", stdout); cin &gt;&gt; n &gt;&gt; K; for (int i=1; i&lt;=n; ++i) cin &gt;&gt; v[i]; for (int i=1; i&lt;=n; ++i) sum[i][i] = v[i]; for (int i=1; i&lt;n; ++i) for (int j=i+1; j&lt;=n; ++j) sum[i][j] = sum[i][j-1] | v[j]; for (int i=1; i&lt;=n; ++i) &#123; point[i].push_back(i); for (int j=i-1; j&gt;=1; --j) if (sum[j][i] != sum[j+1][i]) point[i].push_back(j); &#125; for (int k=1; k&lt;=K; ++k) for (int i=1; i&lt;=n; ++i) &#123; if (i &lt; k) continue; for (int j=0; j&lt;point[i].size(); ++j) &#123; int x = point[i][j]; if (x &gt;= k) f[i][k] = max(f[i][k], f[x-1][k-1] + sum[x][i]); &#125; &#125; cout &lt;&lt; f[n][K] &lt;&lt; endl; return 0;&#125; 树的魔法值（C.cpp, C.in, C.out）【题目描述】 有一棵 k+1 层的满二叉树，那么该树有 2^k 个叶子节点。给定 n 个机器人(n=2^k)， 编号从 1—n，编号为 i 的机器人的权值为 v[i]。我们现在要将这 n 个机器人分别放置在这 n 个叶子节点上，每个叶子节点放且只能放一个机器人。叶子节点的权值为该叶子节点上的机 器人的权值。非叶子节点的权值定义为该树中编号最大的机器人的权值。每个非叶子节点除 了权值以外，还有一个魔法值，该点的魔法值为其左右儿子节点的权值的乘积。整棵树的魔 法值定义为非叶子节点的魔法值的和。 问：将这 n 个机器人随机地放在这 n 个叶子节点上，树的魔法值的期望为多少。 【输入格式】 第一行为一个整数 k，含义如题所示。 第二行为 2^k 个整数，依次表示这 n 个机器人的权值。 【输出格式】 假设答案为一个丌可约分数 P/Q，则输出在模 1e9+7 意义下的 P * (Q^-1)模 1e9+7 的值。 【样例输入 1】 2 1 3 5 7 【样例输出 1】 59 【样例解释】 对于 n=4 的情况，机器人共有 24 种丌同的安放方案。其中，本质丌同的有 3 种，分 别 是 ((1,3),(5,7)), ((1,5),(3,7)), ((1,7),(5,3)) ， 魔 法 值 分 别 为 13+57+3*7=59, 15+37+57=61, 17+53+57=57, 答案为（57+59+61）/3 = 59。 【样例输入 2】 2 1 5 3 7 【样例输出 2】 333333390 【数据范围】 30%的数据，k &lt;= 3 60%的数据，k&lt;= 10 100%的数据，k&lt;= 18 【时空限制】 256MB，1s 考场思路到这个题我只有半个小时了，看不懂样例2（老师讲题时才发现读错题了），想打一个暴力然后发现自己忘了怎么算逆元了，然后就gugu了。大概就按照线段树建树的方式瞎搞了一下，貌似还搞错了…… 考场代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re register#define mod 1000000007#define rep(i,a,b) for(int i = (a); i &lt;= (b); i++)#define qwq printf("qwq\n");using namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;long long n,k,ans,cnt,sum,a[100005],pd[100005],yx[100005];char s[25][40320],now[25];long long ksm(long long x,long long y)&#123; long long ans = 1; while(y &gt; 0) &#123; if(y &amp; 1) ans = (ans * x) % mod; x = (x * x) % mod; y = y &gt;&gt; 1; &#125; return ans % mod;&#125;int check()&#123; for(int i = 1; i &lt;= cnt; i++) if(strcmp(now,s[i]) == 0) return 0; strcpy(s[++cnt],now); return 1;&#125;long long build(int l,int r)&#123; if(l == r) return a[l]; int mid = (l + r) &gt;&gt; 1; int t1 = build(l,mid); int t2 = build(mid + 1,r); sum += t1 * t2; return max(t1,t2);&#125;void tj()&#123; if(check() == 0) return ; sum = 0; build(1,n); ans = ans + sum;&#125;void dfs(int k)&#123; if(k &gt; n) &#123; tj(); return ; &#125; for(int i = 1; i &lt;= n; i++) &#123; if(pd[i]) continue; pd[i] = 1; now[k - 1] = a[i]; yx[k] = a[i]; dfs(k + 1); pd[i] = 0; &#125;&#125;int main()&#123; freopen("c.in","r",stdin); freopen("c.out","w",stdout); k = read(); n = 1 &lt;&lt; k; for(int i = 1; i &lt;= n; i++) a[i] = read(); dfs(1); if(ans % cnt == 0) printf("%lld\n",ans / cnt); else printf("%lld\n",(ans * ksm(cnt,1000000005)) % (1000000007)); fclose(stdin); fclose(stdout); return 0;&#125; 题解 30分：全排列，暴力求期望 60分： 100分 听不懂…… std123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;const int maxn = (1 &lt;&lt; 18) + 7;typedef long long LL;LL fac[maxn], inv_fac[maxn], bit[maxn], sum[maxn];int n, v[maxn], k;int powmod(int x, int times)&#123; LL tmp = 1; while (times &gt; 0) &#123; if (times &amp; 1) tmp = tmp * x % mod; x = (LL)x * x % mod; times &gt;&gt;= 1; &#125; return tmp;&#125;LL C(int x, int y)&#123; if (x &lt; y) return 0; return fac[x] * inv_fac[y] % mod * inv_fac[x-y] % mod;&#125;int main()&#123; freopen("c.in", "r", stdin); freopen("c.out", "w", stdout); fac[0] = 1; for (int i=1; i&lt;maxn; ++i) fac[i] = fac[i-1] * i % mod; inv_fac[maxn-1] = powmod(fac[maxn-1], mod - 2); for (int i=maxn-2; i&gt;=0; --i) inv_fac[i] = inv_fac[i+1] * (i + 1) % mod; bit[0] = 1; for (int i=1; i&lt;=20; ++i) bit[i] = bit[i-1] * 2; scanf("%d", &amp;k); n = bit[k]; for (int i=1; i&lt;=bit[k]; ++i) scanf("%d", &amp;v[i]); LL ans = 0; for (int d=1; d&lt;=k; ++d) &#123; LL tmp = 0; for (int i=n; i&gt;=bit[d]; --i) sum[i] = (sum[i+1] + C(i-1-bit[d-1], bit[d-1]-1) * v[i]) % mod; for (int j=n-1; j&gt;=bit[d-1]; --j) tmp = (tmp + C(j-1, bit[d-1]-1) * v[j] % mod * sum[max(bit[d], (LL)j + 1)]) % mod; ans = (ans + tmp * fac[bit[d-1]] % mod * fac[bit[d-1]] % mod * fac[n-bit[d]] % mod * 2 % mod * bit[k-d]) % mod; &#125; ans = ans * inv_fac[n] % mod; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;anf("%d", &amp;k); n = bit[k]; for (int i=1; i&lt;=bit[k]; ++i) scanf("%d", &amp;v[i]); LL ans = 0; for (int d=1; d&lt;=k; ++d) &#123; LL tmp = 0; for (int i=n; i&gt;=bit[d]; --i) sum[i] = (sum[i+1] + C(i-1-bit[d-1], bit[d-1]-1) * v[i]) % mod; for (int j=n-1; j&gt;=bit[d-1]; --j) tmp = (tmp + C(j-1, bit[d-1]-1) * v[j] % mod * sum[max(bit[d], (LL)j + 1)]) % mod; ans = (ans + tmp * fac[bit[d-1]] % mod * fac[bit[d-1]] % mod * fac[n-bit[d]] % mod * 2 % mod * bit[k-d]) % mod; &#125; ans = ans * inv_fac[n] % mod; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何卡SPFA]]></title>
    <url>%2F2019%2F10%2F19%2F%E5%A6%82%E4%BD%95%E5%8D%A1SPFA%2F</url>
    <content type="text"><![CDATA[正权边卡SPFA的基本思路是弄一个网格图,然后这个网格图行比列小得多,比如10*10000之类的… 然后对于竖着的边边权就设多么小,然后横着的边权就设多么大(比如1和rand()%10000+10) 还可以在图里随机加一些奇怪的边. 然后对于点个数1e5,边个数2e5的有向图,随机打乱边或随机打乱边+SLF的SPFA都被卡到了入队1e8次… PS: 可以将横着的边权构造一下,说不定就可以卡得更大了… 发现随机边权模数不一样差别很大. 另外还有说什么把网格图搞成立方体图不知道会怎么样(因为升了一维嘛…) 代码可以参考一下:这份代码至少可以卡到入队8e7以上 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;struct edge&#123;int u,v,w;&#125;;vector&lt;edge&gt;v;int id[5000][5000],n=9,tp,m=42866/n,a[1000000];int r()&#123; return rand(); //return rand()&lt;&lt;13|rand();&#125;int main()&#123; freopen("in.txt","w",stdout); srand(time(0)); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) id[i][j]=++tp,a[tp]=tp;// random_shuffle(a+1,a+tp+1); int SIZE=29989; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j)&#123; if(i&lt;n)&#123; v.push_back(edge&#123;id[i][j],id[i+1][j],1&#125;); v.push_back(edge&#123;id[i+1][j],id[i][j],1&#125;); if(j&lt;m)&#123; if(1)v.push_back(edge&#123;id[i][j],id[i+1][j+1],r()%SIZE+10&#125;); else v.push_back(edge&#123;id[i+1][j+1],id[i][j],r()%SIZE+10&#125;); &#125; &#125; if(j&lt;m)&#123; v.push_back(edge&#123;id[i][j],id[i][j+1],r()%SIZE+10&#125;); v.push_back(edge&#123;id[i][j+1],id[i][j],r()%SIZE+10&#125;); &#125; &#125; fprintf(stderr,"[%d,%d,%d]",v.size(),n,m); random_shuffle(v.begin(),v.end());// printf("%d %d %d\n",tp,v.size(),2); printf("%d %d\n",tp,v.size()); for(int i=0;i&lt;v.size();++i)printf("%d %d %d\n",a[v[i].u],a[v[i].v],v[i].w);// for(int i=1;i&lt;=10;++i)printf("%d ",a[id[1][10*i]]);// printf("%d %d",a[1],a[2]);&#125; upd:发现一种奇妙的SPFA优化:每次将进队多次的点放到队首,可以过掉这种数据… 然而这个优化可以被一个最naive的数据卡掉…即 addedge(1,i,2*(n-i+1)+1),addedge(i,i-1,1),然后将这些边打乱后输出 这个也是最原始的卡SPFA方法,不加SLF的SPFA可以被这个卡掉 123456789#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; freopen("spfa6.out","w",stdout); int n=99999,m=199996; printf("%d %d\n",n,m); for(int i=n;i&gt;=2;--i) printf("1 %d %d\n%d %d 1\n",i,(n-i+1)*2+1,i,i-1);&#125;]]></content>
      <categories>
        <category>娱乐</category>
      </categories>
      <tags>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1360 【[USACO07MAR]黄金阵容均衡Gold Balanced L…】]]></title>
    <url>%2F2019%2F10%2F19%2F%E9%A2%98%E8%A7%A3-P1360-%E3%80%90-USACO07MAR-%E9%BB%84%E9%87%91%E9%98%B5%E5%AE%B9%E5%9D%87%E8%A1%A1Gold-Balanced-L%E2%80%A6%E3%80%91%2F</url>
    <content type="text"><![CDATA[查看原图请戳这里 首先明确一点，题目求的是最长的每项能力提升大小都相等的区间，所以我们是不用关心一段区间每项能力到底提升了多少，只需要去记录每项能力的大小关系即可。即如果第i天能力x比能力y多k，第j天能力x比能力y也多k，那么在i~j天中x和y的变化量都相等。 所以我们就可以先维护一个二维前缀和来记录每一天每个能力的能力值，再用相邻两行做差来记录大小关系。于是，我们只需要去寻找x，y，使得第x天的大小关系与第y天相同且y-x尽可能大。我们可以发现，如果暴力枚举去寻找，复杂度是$O(n^2)$的，所以我们可以先对这个表示大小关系的二维矩阵的列排序，再去$O(n)$统计答案。 code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re register#define rep(i,a,b) for(int i = (a); i &lt;= (b); i++)#define qwq printf("qwq\n");using namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;int n,m,x,y,ans,cnt,flag,f[37][1000015],h[37][1000015],e[100005];struct two&#123; int num[47],p;&#125;g[1000015];void broke(int x,int i)&#123; int cnt = 0; while(x &gt; 0) &#123; f[++cnt][i] = x &amp; 1; x &gt;&gt;= 1; &#125;&#125;void init()&#123; n = read(); m = read(); for(int i = 1; i &lt;= n; i++) &#123; y = x; x = read(); e[i] = x; if(x != y &amp;&amp; x &gt; 1) flag = 1; broke(x,i); &#125;&#125;void make1()&#123; for(int i = 1; i &lt;= m; i++) for(int j = 1; j &lt;= n; j++) f[i][j] = f[i][j - 1] + f[i][j];&#125;int mysort(two a,two b)&#123; int k = 1; while(a.num[k] == b.num[k] &amp;&amp; k &lt;= m) k++; if(k &lt;= m) return a.num[k] &lt; b.num[k]; return a.p &lt; b.p;&#125;void make2()&#123; for(int i = 2; i &lt;= m; i++) for(int j = 1; j &lt;= n; j++) g[j].num[i] = f[i][j] - f[i - 1][j],g[j].p = j; sort(g, g + n + 1,mysort);&#125;bool cmp(int a,int b)&#123; for(int i = 1; i &lt;= m; i++) if(g[a].num[i] != g[b].num[i]) return false; return true;&#125;void find()&#123; ans = 0; int head = 0; while(head &lt; n) &#123; int k = head; while(cmp(k + 1,head) &amp;&amp; k &lt; n) k++; if(k &lt;= n) ans = max(ans,g[k].p - g[head].p); head = k + 1; &#125;&#125;int main()&#123; init(); if(flag == 0) &#123; int k = 0; while(e[k + 1] == 0 &amp;&amp; k &lt; n) k++; printf("%d\n",k); return 0; &#125; make1(); make2(); find(); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2886 【[USACO07NOV]牛继电器Cow Relays】]]></title>
    <url>%2F2019%2F10%2F19%2F%E9%A2%98%E8%A7%A3-P2886-%E3%80%90-USACO07NOV-%E7%89%9B%E7%BB%A7%E7%94%B5%E5%99%A8Cow-Relays%E3%80%91%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 首先，我们要明确这里的最短路是在经过n条路径的前提下的最短路，因为这是无向图，所以一定有解。 我们先来看朴素的Floyd的代码： 1234for(int k = 1; k &lt;= n; k++) for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) f[i][j] = min(f[i][j],f[i][k] + f[k][j]); 其中，我们每次都是枚举k并用ta去当中转点去更新每一个i-&gt;j的最短路。 那么，当k等于n/2时这段代码完成了什么呢？ 那就是我们尝试了用[1,n/2]的点去更新最短路，我们可以发现，这样得到的最短路最多包含k+1条路径。 为什么是最多k+1条呢？ 因为我们每次用k去尝试更新i-&gt;j的最短路是不一定成功（即f[i][j]&lt;=f[i][k]+f[k][j]） 所以我们可以用Floyd+dp+倍增去切掉这道题 我们再来看一下矩阵乘法的代码： 1234for(int k = 1; k &lt;= n; k++) for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) c[i][j] = c[i][j] + a[i][k] * b[k][j]; 是不是和Floyd的代码有点相似？ 因为我们要求的是最短路，所以我们要对这个矩阵乘法魔改一下： 12345memset(c,0x7f,sizeof(c));for(int k = 1; k &lt;= n; k++) for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) c[i][j] = min(c[i][j],a[i][k] + a[k][j]); 是不是和Floyd越来越相似了…… 但是在这里，c[i][j]的初值为INF，所以我们每次枚举k都会选择一条边去更新最短路，所以如果我们用邻接矩阵map（不是STL的那个map）去存边，那么map的n次方存的就是经过n条边的最短路。 code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re register#define rep(i,a,b) for(int i = (a); i &lt;= (b); i++)#define qwq printf("qwq\n");using namespace std;long long read()&#123; register long long x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;long long n,m,t,sta,End,cnt,siz,u,d[100005];struct edge&#123; int fro,to,l;&#125;e[100005];struct juzhen&#123; long long a[105][105]; juzhen operator * (const juzhen &amp;x) const &#123; juzhen c; memset(c.a,0x7f,sizeof(c.a)); for(int k = 1; k &lt;= siz; k++) for(int i = 1; i &lt;= siz; i++) for(int j = 1; j &lt;= siz; j++) c.a[i][j] = min(c.a[i][j],a[i][k]+x.a[k][j]); return c; &#125;&#125;ans,map; void ksm(int b)&#123; while(b &gt; 0) &#123; if(b &amp; 1) ans = ans * map; map = map * map; b &gt;&gt;= 1; &#125;&#125;bool cmp(int a,int b)&#123;return a &lt; b;&#125;int main()&#123; n = read(); m = read(); sta = read(); End = read(); for(int i = 1; i &lt;= m; i++) &#123; e[i].l = read(); e[i].fro = read(); e[i].to = read(); d[++cnt] = e[i].fro; d[++cnt] = e[i].to; &#125; sort(d + 1, d + cnt + 1, cmp); siz = unique(d + 1, d + cnt + 1) - d - 1; for(int i = 1; i &lt;= siz; i++) for(int j = 1; j &lt;= siz; j++) map.a[i][j] = INF; for(int i = 1; i &lt;= m; i++) &#123; e[i].fro = lower_bound(d + 1, d + siz + 1, e[i].fro) - d; e[i].to = lower_bound(d + 1, d + siz + 1, e[i].to) - d; map.a[e[i].fro][e[i].to] = e[i].l; map.a[e[i].to][e[i].fro] = e[i].l; &#125; sta = lower_bound(d + 1, d + siz + 1, sta) - d; End = lower_bound(d + 1, d + siz + 1, End) - d;// li san hua for(int i = 1; i &lt;= siz; i++) for(int j = 1; j &lt;= siz; j++) ans.a[i][j] = map.a[i][j]; ksm(n - 1); printf("%d\n",ans.a[sta][End]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>矩阵乘法</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3667 【[USACO17OPEN]Bovine Genomics G奶牛基因组（金）】]]></title>
    <url>%2F2019%2F10%2F19%2F%E9%A2%98%E8%A7%A3-P3667-%E3%80%90-USACO17OPEN-Bovine-Genomics-G%E5%A5%B6%E7%89%9B%E5%9F%BA%E5%9B%A0%E7%BB%84%EF%BC%88%E9%87%91%EF%BC%89%E3%80%91%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 首先，这道题让求最大值最小，于是我们就很自然得想到了去二分这个最小值。 那么，怎么check呢？ 我们发现，如果直接暴力去check，即二分区间长度+暴力枚举字符串+暴力枚举区间左端点+暴力对比，那么时间复杂度是$O(n^2m^2\log_2n)$的。（引人深思的复杂度……） 很显然，我们需要去优化这个时间复杂度。 首先，如果我们对要进行对比的区间进行哈希，然后用set进行判断，就可以将时间复杂度降低到$O(nm^2\log_2^2n)$。 这里提供两种用set去检验的思路： 用一个set去记录好的基因有多少不同的哈希值$cnt1$，再用一个set去记录坏的基因有多少不同的哈希值$cnt2$，再用一个set去记录好的基因和坏的基因一共有多少不同的哈希值$cnt3$，如果$cnt3-cnt1=cnt2$，那么好的基因的哈希值和坏的基因的哈希值没有重复。 用一个set去储存好的基因的哈希值，然后用set自带的find函数查询每一个坏的基因的哈希值是否在这个集合中出现过。 但是，即便如此，我们的时间复杂度依然无法通过这道题，主要原因是每次记录哈希值都占用了大量的时间。$hash[i]-hash[j-1]\times pri^{i-j+1}(i&gt;j)$快速求得$hash[i][j]$的值。 时间复杂度：$O(nm\log_2 n)$ code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#define ll long long#define INF 0x7fffffff#define re register#define rep(i,a,b) for(int i = (a); i &lt;= (b); i++)#define qwq printf("qwq\n");#define mod1 122420729#define mod2 131937371using namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;int n,m,l,r,mid,cnt1,cnt2,cnt3;long long hfg[505][505],hfb[505][505],a[505],b[505],c[505];char good[505][505],bad[505][505];void Hash()&#123; memset(hfg,0,sizeof(hfg)); memset(hfb,0,sizeof(hfb)); for(register int i = 0; i &lt; n; i++) hfg[i][0] = good[i][0]; for(register int i = 0; i &lt; n; i++) hfb[i][0] = bad[i][0]; for(register int i = 0; i &lt; n; i++) for(register int j = 1; j &lt; m; j++) hfg[i][j] = hfg[i][j - 1] * 13331 + good[i][j]; for(register int i = 0; i &lt; n; i++) for(register int j = 1; j &lt; m; j++) hfb[i][j] = hfb[i][j - 1] * 13331 + bad[i][j];&#125;void get_Hash(int s,int l)&#123; if(s == 0) &#123; for(int i = 0; i &lt; n; i++) a[i] = hfg[i][l - 1]; for(int i = 0; i &lt; n; i++) b[i] = hfb[i][l - 1]; return ; &#125; for(int i = 0; i &lt; n; i++) a[i] = hfg[i][s + l - 1] - hfg[i][s - 1] * c[l]; for(int i = 0; i &lt; n; i++) b[i] = hfb[i][s + l - 1] - hfb[i][s - 1] * c[l];&#125;set&lt;int&gt; se1,se2,se3;bool check(int l)&#123; for(register int i = 0; i + l - 1 &lt; m; i++) &#123; get_Hash(i,l); int flag = 1; se1.clear(); se2.clear(); se3.clear(); for(register int j = 0; j &lt; n; j++) se1.insert(a[j]),se3.insert(a[j]); cnt1 = se1.size(); for(register int j = 0; j &lt; n; j++) se2.insert(b[j]),se3.insert(b[j]); cnt2 = se2.size(); if(se3.size() - cnt1 == cnt2) return true; &#125; return false;&#125;int main()&#123; n = read(); m = read(); c[1] = 13331; for(int i = 2; i &lt;= m; i++) c[i] = c[i - 1] * 13331; for(register int i = 0; i &lt; n; i++) cin &gt;&gt; good[i]; for(register int i = 0; i &lt; n; i++) cin &gt;&gt; bad[i]; l = 1; r = m; Hash(); while(l &lt; r) &#123; mid = (l + r) &gt;&gt; 1; if(check(mid)) r = mid; else l = mid + 1; &#125; get_Hash(1,4); printf("%d\n",r); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>二分</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019国庆清北刷题营]]></title>
    <url>%2F2019%2F10%2F19%2F2019%E5%9B%BD%E5%BA%86%E6%B8%85%E5%8C%97%E5%88%B7%E9%A2%98%E8%90%A5%2F</url>
    <content type="text"><![CDATA[图论图论部分转载于Shu_Yu_Mo の blog 2-SATSomeThing 又名2-SAT-2 判断有无解 确定变量 确定关系表达式 变量的取值有两种 %d - SAT 表达式有多少个变量 SAT - %d 每个变量的情况个数 加边规则 如果$x−−&gt;yx –&gt; yx−−&gt;y$，表示确定x即可确定y。 (当某个点必须为某个值的时候，自身连边，例：当必须为true时，就false连向true) 例题 POJ2446 HDU3622 UVA1514 Piece it together UVA1086 The Ministers’ Major Mess HDU4306 二分图SomeThing 此图是树 =&gt; 此图是二分图 此图是二分图 =&gt; 此图是树 二分图两边的点数量为n,m，匹配值是x，最大独立集数量为n+m-x 例题给出一张图，删一条边，使之成为二分图（CF 19E Fairy 最大团SomeThing 给一张图，求最大团 —&gt; NPC。 所以很多问题中，求最大团的图有很多特殊性质。 求最大团的方法 （wait）。 补图 —&gt; 把图之前的图上的边全都删掉，没有的边全都加上。 原图的反图中的最大独立集就是最大团 例题 【HEOI2012】朋友圈 最大独立集 原图的反图就是最大团。 在二分图中，独立集的个数为，n+m−x CSP-Algorithm图论 Tarjan 二分图 2-SAT 最小生成树 最短路 模拟 灭鼠计划 猪国杀 立体图 操作系统 靶形数独 [THUPC2018]组合数问题 SomeThing 题目中的一些奇怪的数字为突破口 cdqz.openjudge.cn 动态规划DP的三种方法 记忆化搜索 用自己算别人 用别人算自己 排列类dp 把数字从小到大or从大到小一个一个插入 一个序列的前缀也是一个前缀 在1~k的排列中加入i，可以将大于等于i的数字全部加1，然后再插入i。 例题例题1：求在一颗无限大的满二叉树上取n个点取到第k层的方案数。一个非根节点只有当它的父亲节点被选择是才可以被选。 思路：把根拆掉变成两颗更小的树。 $$ans = f[n][n] - f[n][k-1]$$ 例题2： 状态：$f[i][j][k]$ 用了j个i-1，i，i+1与k个i，i+1，i+2的方案，枚举l个i+1，i+2，i+3。 题目链接：https://www.luogu.org/problem/CF1110D 例题3： 一般思路：维护前i轮下来逆序对的和。但是不知道转移时交换的两个数的大小关系。很显然，这样不行。 提示：期望的和=和的期望 -&gt; 所有方案的逆序对数=枚举两个位置交换，在所有方案中有多少种方案会形成逆序对。 $f[i][j][k]$表示在i轮之后i,j小于i,k的方案数。 求有多少j&gt;k但i,j小于i,k。 我们考虑暴力枚举i，j来统计逆序对数，那么$\sum 逆序对数 = \sum 方案(\sum i *\sum j)$。 l是用来枚举位置j交换后会对增加/减少多少逆序对。 题目来源： At coder Inversion Sun 030D(大概是这个) 写题流程 想思路 翻译成代码 调试 调试技巧对拍 工具 你的程序 暴力程序 数据生成器 对拍程序 结果 一样： 都对了 错到一块了qwq 不一样： 至少一个错的 帮你找到调试用的数据 用处： 帮你找到一组错误的数据 效率： 写错了 -&gt; 一般很快就出问题 对拍程序： 1234567891011121314#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;int main()&#123; while(true) &#123; system("data.exe"); system("std.exe"); system("brute.exe"); if(system("fc std.out brute.out")) break; &#125;&#125; 产生1~n的排列 windows产生rand(rand()自身最大值很小)： 树的生产方法 纯随机 扫把图： 生成图 直接生产 用map or set把重边去掉 连通图：先生成一颗树，再随机加边 DAG：i -&gt; j 当且仅当i &lt; j 强制在线：把暴力写入数据生成器中。可以直接生产离线数据，方便对拍，拍完了把代码改成强制在线。 数论exgcd用法：求$ax+by=gcd(a,b)$的一组整数解，或者判断$ax+by=k$是否有解 线性筛筛素数核心思想：一个数大于1的倍数一定是合数。 欧拉筛分：一个数，一定能被质因数分解。 $x=p1^k1p2^k2……*pn^kn$ $x=p1p1^{k1-1}*p2^k2……*pn^kn$ 欧拉函数phi(i)表示小于等于i的数里面与i互素的数的个数 $phi(x)=x(1-1/p1)(1-1/p2)…(1-1/pn)$ 求一个数的phi &lt;==&gt; 求这个数的质因数分解 性质： $phi(1)=1$(唯一和1互质的数就是1本身) 若$n$是素数，则$phi(n)=n-1$ 若$n$是合数，则$phi(n)&lt;n-1$ 当$n$为奇数时，则$phi(2n) = phi(n)$ 若$a$、$b$互质，则$phi(ab)=phi(a)phi(b)$ 组合数 #### 逆元 欧拉定理&amp;feim Lucas定理$Lucas(n,m,p)=C(n%p,m%p)*Lucas(n/p,m/p,p)$ 中国剩余定理(crt) 先将P分解质因数，得到其质因子 用Lucas定理求$C(n,m)=X_i(mod \ pi)$ 合并两个相邻的同余方程，要求gcd(p1,p2) = 1 C(n,m)=x1(mod p1) C(n,m)=x2(mod p2) C(n,m)=p1*k1+x1=p2*k2+x2 ==&gt; exgcd p1*k1 - p2*k2 = x2 - x1 用exgcd求出一组整数解(k1,k2) C(n,m) = p1 * k1 + x1 (mod p1 * p2) 高斯消元【HNOI2013】游走 大步小步算法(BSGS)给定a，y，p，求最小的非负整数x，使得$a^x=y(mod\ p)$ Bzoj2242：[SDOI2011]计算器 例题 CSP-S会涉及到的数学相关的知识 快速幂 矩阵乘法 GCD/exGCD 筛素数/素数判断 欧拉函数 逆元 组合数取模/卢卡斯定理 中国剩余定理 高斯消元 模拟例题 时间复杂度 P3585 [POI2015]PIE P3492 [POI2009]TAB-Arrays 贪心例题 P3419[POI2005]SAM-Toy Cars 贪心策略：优先替换下一次出现时间晚的玩具，因为下一次出现得越晚，它闲置的时间最长，可以少占用地板的空间。 [CF898D]Alarm Clock 贪心策略：优先删每一段时间靠后的闹钟 P3545[POI2012]HUR-Warehouse Store [CF954E] Water Taps P3457 [POI2007]POW-The Flood P3566 [POI2014]KLO-Bricks 考试策略 开考前把考试前最终需要检查的东西写一下。 前10~15分钟读题：读懂题，知道题在干什么，知道样例是怎么算的。 5分钟选择做题顺序，这时候还没有想出来题还没有怎么做，凭直觉把题目安装难度排序。 约1.5h写完每个题目的暴力，理想暴力分数：T1 100分，T2 60分，T3 30分。 接下来按照平时做题的方法去写一百分/更多部分分的做法。 最后10到15分钟停止虐键盘，检查文件，编译，调试信息，数组大小，初始化等等。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>动态规划</tag>
        <tag>数论</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 SP15637 【GNYR04H - Mr Youngs Picture Permutations】]]></title>
    <url>%2F2019%2F09%2F19%2F%E9%A2%98%E8%A7%A3-SP15637-%E3%80%90GNYR04H-Mr-Youngs-Picture-Permutations%E3%80%91%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 一道五维DP的题目 首先，我们发现，当我们排完部分队形时，已经排好的队形对后续的方案数是有影响的，显然我们这样DP是非常困难的。所以，我们可以选择安装身高顺序插入，每次的决策是第i个人插入的位置。 我们可以发现，如果我们要向第i行的末尾插入一个人，那么第i行的状态必须满足以下两个条件： $l_i&lt;k_i$ $l_i&lt;l_i-1 \ || \ i = 1 $ 第一个条件是保证第i行的人数不会超出上限，第二个条件用来保证列与列直接的单调性。 对于数组的大小，我们发现开$30^5$其实是一个非常大的级别。于是，我们可以这样开： 1long long f[31][16][11][9][7]; 解释一下： 因为第i行的人数一定小于等于第i - 1行的人数，所以第i行最多放$30 / i$个人。 code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re register#define rep(i,a,b) for(int i = (a); i &lt;= (b); i++)#define qwq printf("qwq\n");using namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;long long f[31][16][11][9][7],n,k[100005];int main()&#123; while(1) &#123; n = read(); if(!n) break; memset(k,0,sizeof(k)); memset(f,0,sizeof(f)); f[0][0][0][0][0] = 1; for(int i = 1; i &lt;= n; i++) k[i] = read(); for(int a = 0; a &lt;= k[1]; a++) for(int b = 0; b &lt;= k[2]; b++) for(int c = 0; c &lt;= k[3]; c++) for(int d = 0; d &lt;= k[4]; d++) for(int e = 0; e &lt;= k[5]; e++) &#123; if(a &lt; k[1])f[a + 1][b][c][d][e] += f[a][b][c][d][e]; if(b &lt; a &amp;&amp; b &lt; k[2])f[a][b + 1][c][d][e] += f[a][b][c][d][e]; if(c &lt; b &amp;&amp; c &lt; k[3])f[a][b][c + 1][d][e] += f[a][b][c][d][e]; if(d &lt; c &amp;&amp; d &lt; k[4])f[a][b][c][d + 1][e] += f[a][b][c][d][e]; if(e &lt; d &amp;&amp; e &lt; k[5])f[a][b][c][d][e + 1] += f[a][b][c][d][e]; &#125; printf("%lld\n",f[k[1]][k[2]][k[3]][k[4]][k[5]]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP，动态规划</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高斯消元]]></title>
    <url>%2F2019%2F08%2F23%2F%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%2F</url>
    <content type="text"><![CDATA[作用高斯消元可以用来解线性方程组，也有一些别的用途。 算法流程我们来看这样的一个方程组： $ x+y+z=3$ $2x+3y+z= 6$ $4x+y+2z=7$ 然后我们把每一项的系数提取出来，就得到如下的矩形 ： $1 \ 1 \ 1 \ 3 $ $ 2 \ 3 \ 1 \ 6 $ $ 4 \ 1 \ 2 \ 7 $ 然后，我们就可以用矩阵的第一行乘$(a[i][1]\div a[1][1])$加到矩阵的第2行、第3行，使矩阵的2~3行的第1项变为0。如图： $ 1 \ \ \ \ 1 \ \ \ \ 1 \ \ \ \ 3 $ $ 0 \ \ \ \ 1 \ -1 \ \ \ \ 0 ​$ $ 0 \ -3 \ -2 \ -5 ​$ 然后我们再用第2行乘3并加到第三行，使第3行的第2项边为0。 如图： $ 1 \ \ \ \ 1\ \ \ \ 1 \ \ \ \ 3 $ $ 0 \ \ \ \ 1 \ -1 \ \ \ \ 0 $ $ 0 \ \ \ \ 0 \ -5 \ -5 $ 然后我们发现矩阵第3行只有一个未知数$z$，于是我们就可以直接求出$z$ 的值，然后第2行就只有一个未知数$y$了。求出$y$后第一行就只有一个未知数$x$。这样，我们就求出了这个方程组的解。 所以说，我们需要通过某些操作使得矩形变成只有一个倒三角上的数字可以不为0，然后依次求解每一个未知数的值。 注： 对于一个有n个未知数的方程组，若在矩阵处理完毕后前n列有至少一列上的数字全部为0，则该方程有多解，即这一行系数所对应的边量可以取任意值。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re register#define qwq printf("qwq\n");using namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;double a[105][105],Max,x[105];int n,flag;void gauss(int n)&#123; int k; for(int i = 1; i &lt; n; i++) &#123; k = i; Max = 0; for(int j = i + 1; j &lt;= n; j++) if(Max &lt; fabs(a[j][i])) Max = a[j][i], k = j; if(k != i) for(int j = i; j &lt;= n + 1; j++) swap(a[k][j],a[i][j]); for(int j = i + 1; j &lt;= n; j++) &#123; double b = (a[j][i] / a[i][i]); for(int k = i; k &lt;= n + 1; k++) a[j][k] = a[j][k] - a[i][k] * b; &#125; &#125; for(int i = n; i &gt;= 1; i--) &#123; if(a[i][i] == 0) &#123;printf("No Solution\n"); flag = 1; return ;&#125; for(int j = i + 1; j &lt;= n; j++) a[i][n + 1] = a[i][n + 1] - a[i][j] * x[j]; x[i] = a[i][n + 1] / a[i][i]; &#125;&#125; int main()&#123; n = read(); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n + 1; j++) scanf("%lf",&amp;a[i][j]); gauss(n); if(flag) return 0; for(int i = 1; i &lt;= n; i++) printf("%.2f\n",x[i]); return 0;&#125;]]></content>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[筛法]]></title>
    <url>%2F2019%2F08%2F15%2F%E7%AD%9B%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这里给出的两份代码都是关于洛谷P3383 【模板】线性筛素数的。两份代码不是一块敲的，码风可能稍有区别。 Eratosthenes筛法Eratosthenes筛法的核心思想是对于任何一个数，它的整倍数一定不是素数。时间复杂度：$O(n log log n)​$code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;int n,m,su[10000005];void make()&#123; int k = sqrt(n + 1); for(int i = 2; i &lt;= k; i++) &#123; if(su[i]) continue; for(int j = i * i;j &lt;= n; j = j + i) su[j] = 1; &#125; &#125;int main()&#123; n = read(); m = read(); make(); su[1] = 1; su[0] = 1; for(int i = 1; i &lt;= m; i++) &#123; n = read(); printf(su[n] ? "No\n" : "Yes\n"); &#125; return 0;&#125; Euler筛法Euler筛法也叫欧拉筛。Euler筛法的特点是对于每一个合数，我们只会用它的最小质因数去筛去它，所以Euler筛法的时间复杂度是$O(n)$的。code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re register#define qwq printf("qwq\n");using namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;int n,m,x,cnt,vis[10000005],pri[10000005];void work()&#123; vis[1] = 1; for(int i = 2; i &lt;= n; i++) &#123; if(!vis[i]) pri[++cnt] = i; for(int j = 1; j &lt;= cnt &amp;&amp; i * pri[j] &lt;= n; j++) &#123; vis[i * pri[j]] = 1; if(i % pri[j] == 0) break; &#125; &#125;&#125;int main()&#123; n = read(); m = read(); work(); for(int i = 1; i &lt;= m; i++) &#123; x = read(); if(vis[x]) printf("No\n"); else printf("Yes\n"); &#125; return 0;&#125; 我们可以看一下这两份代码的运行速度：]]></content>
      <tags>
        <tag>筛法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1129 【[ZJOI2007]矩阵游戏】]]></title>
    <url>%2F2019%2F08%2F15%2F%E9%A2%98%E8%A7%A3-P1129-%E3%80%90-ZJOI2007-%E7%9F%A9%E9%98%B5%E6%B8%B8%E6%88%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里首先，题目告诉我们有以下两种操作： 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色） 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色 但是，实际上我们只需要进行其中的一种操作就可以了。即我们两种操作混着用其实是没有什么效果的，这一点后文会解释到。 假设我们只交换行，那么如果有一行是这样的：$$0\ 1\ 0\ 0$$那么很显然，这一列能且只能在第二行上。再看一个例子：$$0\ 1\ 1\ 0$$我们发现，这一行既可以放到第二行，也可以放到第三行。所以，如果第i行需要在第k列上的颜色为黑色（数字为1），那么我们就将i和k连一条边。注意，这一步看上去是行和列匹配，但实际上则是边和边进行匹配——第i条边可以放到第k条边的位置上。因为对于一个正方形，其左上-右下的对角线会经过第k条边的第k个位置。然后我们就可以去跑二分图最大匹配，若匹配数等于边数，则有解，否则无解。为什么只考虑一种操作就可以了呢？如图，我们发现第3列没有黄格，第2列有2个黄格，但交换了第2、3列以后，第2列就没有黄格了。所以说，在进行一种操作的基础上，进行另一种操作无非是拆东墙，补西墙。code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re register#define qwq printf("qwq\n");using namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;int n,cnt,x,tot,T,d[100005];int with[100005],pd[100005];struct edge&#123; int next,to,from;&#125;e[200005];void add(int x,int y)&#123; e[++cnt].to = y; e[cnt].from = x; e[cnt].next = d[x]; d[x] = cnt;&#125;int find(int u)&#123; for(int i = d[u]; i; i = e[i].next) &#123; int v = e[i].to; if(!pd[v]) &#123; pd[v] = 1; if(with[v] == 0 || find(with[v])) &#123; with[v] = u; return 1; &#125; &#125; &#125; return 0;&#125;void cl()&#123; for(int i = 1; i &lt;= cnt; i++) e[i].to = 0; cnt = 0; tot = 0; memset(d,0,sizeof(d)); memset(with,0,sizeof(with));&#125;int main()&#123; T = read(); while(T--) &#123; n = read(); cl(); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) &#123; x = read(); if(x) add(i,j); &#125; for(int i = 1; i &lt;= n; i++) &#123; memset(pd,0,sizeof(pd)); if(find(i)) tot++; &#125; if(tot == n) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>二分图</tag>
        <tag>最大匹配</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3203 【[HNOI2010]弹飞绵羊】]]></title>
    <url>%2F2019%2F08%2F14%2F%E9%A2%98%E8%A7%A3-P3203-%E3%80%90-HNOI2010-%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A%E3%80%91%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里我们先来看一下这道题如果先转化成森林再处理的话，一共有如下几个操作： 删除一条边 加入一条边 查询两点间路径权值和 这不是一道LCT的题吗……然而LCT代码复杂度太高了，这里我们来讲一下如何用分块来解决这道题。首先，我们将这$n$个装置分成$\sqrt n$块，每块有$\sqrt n$个元素。然后，我们记录下每个元素跳出ta所在块所需要的步数以及ta会跳到哪里。然后，对于每次修改，我们就用$O(n)$的复杂度去修改一个块中所有元素的值；对于每次查询，我们就一个块一个块条。时间复杂度：$O(\sqrt n)$code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re register#define qwq printf("qwq\n");using namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;int n,m,x,y,z,a[200005],l[100005],r[100005],len,num,to[200005],cnt[200005],blog[200005];void clannad(int k)&#123; for(int i = r[k]; i &gt;= l[k]; i--) &#123; blog[i] = k; if(i + a[i] &gt; r[k]) to[i] = i + a[i],cnt[i] = 1; else to[i] = to[i + a[i]],cnt[i] = cnt[i + a[i]] + 1; &#125;&#125;void change(int k)&#123; int u = blog[k]; for(int i = k; i &gt;= l[u]; i--) &#123; if(i + a[i] &gt; r[u]) to[i] = i + a[i],cnt[i] = 1; else to[i] = to[i + a[i]],cnt[i] = cnt[i + a[i]] + 1; &#125;&#125;int query(int k,int sum)&#123; if(k &gt; n) return sum; return query(to[k],sum + cnt[k]);&#125;int main()&#123; n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(); len = sqrt(n); num = n / len; if(n % len) num++; for(int i = 1; i &lt;= num; i++) l[i] = (i - 1) * len + 1,r[i] = i * len; r[num] = n; for(int i = 1; i &lt;= num; i++) clannad(i); m = read(); for(int i = 1; i &lt;= m; i++) &#123; x = read(); y = read() + 1; if(x == 1) printf("%d\n",query(y,0)); if(x == 2) &#123; z = read(); a[y] = z; change(y); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1004 【方格取数】]]></title>
    <url>%2F2019%2F08%2F13%2F%E9%A2%98%E8%A7%A3-P1004-%E3%80%90%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E3%80%91%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里一道典型的区间dp。一共需要走两次，我们不妨同时处理这两条路径。这样，我们既可以方便地处理两条路径重合的情况，也可以减少代码的时间复杂度。最朴素的想法是开一个四维数组$f[x_1][y_1][x_2][y_2]$表示当两条路径分别处理到$(x_1,y_1)$和$(x_2,y_2)$时能够获得的最大的累积和。但是，四维数组处理起来时间复杂度太大了，所以我们要想办法把它降成三维。我们可以发现，每当我们走一步，那么x坐标和y坐标之间总会有一个数加$1$。所以，我们可以用k来表示x坐标和y坐标的和，从而通过y坐标来计算出x坐标。由于k对于两条同时处理的路径可以是公共的，所以我们可以用$f[k][y_1][y_2]$来表示当前状态。特殊的，由于每一个方格的数只可以取一次，所以我们要判断i和j是否相当。于是，我们就可以得到一个状态转移方程了：$$f[k][i][j]=max(f[k-1][i][j],f[k-1][i-1][j]f[k-1][i][j-1]f[k-1][i-1][j-1])+[(i==j)?map[k-i+1][i]:map[k-i+1][i] + map[k-j+1][j]]$$我们可以来看一下我们到底是通过哪些状态转移到当前状态的：code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re register#define qwq printf("qwq\n");using namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;int n,m,map[205][205],f[205][205][205],x,y,v;int cmp(int a,int b,int c,int d)&#123; a = max(a,b); c = max(c,d); return max(a,c);&#125;int main()&#123; m = read(); n = m; x = read(); y = read(); v = read(); while(x &gt; 0) &#123; map[x][y] = v; x = read(); y = read(); v = read(); &#125; for(int k = 1; k &lt;= m + n; k++) for(int i = 1; i &lt;= min(k,n); i++) for(int j = 1; j &lt;= min(k,n); j++) &#123; f[k][i][j] = cmp(f[k - 1][i][j],f[k - 1][i - 1][j],f[k - 1][i][j - 1],f[k - 1][i - 1][j - 1]) + map[k - i + 1][i] + map[k - j + 1][j]; if(i == j) f[k][i][j] -= map[k - i + 1][i]; &#125; f[n + m][n][n] = cmp(f[n + m - 1][n][n - 1],f[n + m - 1][n - 1][n],f[n + m - 1][n][n],f[n + m - 1][n - 1][n - 1]); printf("%d\n",f[n + m][n][n]); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划，dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1006 【传纸条】]]></title>
    <url>%2F2019%2F08%2F13%2F%E9%A2%98%E8%A7%A3-P1006-%E3%80%90%E4%BC%A0%E7%BA%B8%E6%9D%A1%E3%80%91%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 前言这道题我做了半年qwq一道非常典型的区间dp题目要求是从小渊到小轩再回到小渊，那么我们不妨从小渊开始求两条不重合的去小轩的路径。如图，当我们找到了一条路径后，那么这张图就被分成了两部分，我们的另一条路径只可能存在于其中的一部分中，像这样：我们可以用$f[x_1][y_1][x_2][y_2]$表示两次传递分别到$(x_1,y_1)$和$(x_2,y_2)$是能够获得的最大好感度。但是，这个数组的维度太高了，所以我们要对他降维。怎么降维呢？扔一个三向箔我们可以发现，每当我们走一步，那么x坐标和y坐标之间总会有一个数加$1$。所以，我们可以用k来表示x坐标和y坐标的和，从而通过y坐标来计算出x坐标。由于k对于两条同时处理的路径可以是公共的，所以我们可以用$f[k][y_1][y_2]$来表示当前状态。于是，我们就可以得到一个状态转移方程了：$$f[k][i][j]=max(f[k-1][i][j],f[k-1][i-1][j]f[k-1][i][j-1]f[k-1][i-1][j-1])+map[k-i+1][i]+map[k-j+1][j]​$$我们可以来看一下我们到底是通过哪些状态转移到当前状态的：code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re register#define qwq printf("qwq\n");using namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;int n,m,map[205][205],f[205][205][205]; int cmp(int a,int b,int c,int d)&#123; a = max(a,b); c = max(c,d); return max(a,c);&#125;int main()&#123; m = read(); n = read(); for(int i = 1; i &lt;= m; i++) for(int j = 1; j &lt;= n; j++) map[i][j] = read(); for(int k = 1; k &lt;= m + n; k++) for(int i = 1; i &lt;= min(k,n); i++) for(int j = i + 1; j &lt;= min(k,n); j++) f[k][i][j] = cmp(f[k - 1][i][j],f[k - 1][i - 1][j],f[k - 1][i][j - 1],f[k - 1][i - 1][j - 1]) + map[k - i + 1][i] + map[k - j + 1][j]; f[n + m][n][n] = max(f[n + m - 1][n][n - 1],f[n + m - 1][n - 1][n]); printf("%d\n",f[n + m][n][n]); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划，dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1776 【宝物筛选_NOI导刊2010提高（02）】]]></title>
    <url>%2F2019%2F08%2F10%2F%E9%A2%98%E8%A7%A3-P1776-%E3%80%90%E5%AE%9D%E7%89%A9%E7%AD%9B%E9%80%89-NOI%E5%AF%BC%E5%88%8A2010%E6%8F%90%E9%AB%98%EF%BC%8802%EF%BC%89%E3%80%91%2F</url>
    <content type="text"><![CDATA[题意简述给你$n$个物品，第$i$个物品的体积为$w_i$,价值为$v_i$,可以选$m_i$次。现在你可以选的物品总体积不超过$W$，求你能获得的最大的价值 解题思路感觉把多重背包的问题模型重温了一遍有没有……由于数据范围很大，所以我们直接将选$m$次拆成有$m$个物品可选这个暴力的方案是会超时的，所以我们要用二进制分解去优化多重背包。我们用$W_{i,j}$表示为由$2^j$个物品$i$捆绑而成的大物品。若$m$不是$2$的整数次幂，那么我们应将物品$i$进行二进制分解以后剩下的选取次数捆绑成一个大物品并单独储存。二进制分解完成后，我们再跑朴素的0/1背包求解即可。 code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re register#define qwq printf("qwq\n");using namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;int n,f[100005],ans,cnt,m,w[100005],v[100005],W,V,t;int main()&#123; n = read(); t = read(); for(int i = 1; i &lt;= n; i++) &#123; V = read(); W = read(); m = read(); for(int j = 1; j &lt;= m; j &lt;&lt;= 1) &#123; w[++cnt] = W * j; v[cnt] = V * j; m -= j; &#125; if(m) w[++cnt] = W * m,v[cnt] = V * m; &#125; for(int i = 1; i &lt;= cnt; i++) for(int j = t; j &gt;= w[i]; j--) f[j] = max(f[j],f[j - w[i]] + v[i]); cout &lt;&lt; f[t]; return 0;&#125;]]></content>
      <tags>
        <tag>动态规划，dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 SP116 【INTERVAL - Intervals】]]></title>
    <url>%2F2019%2F08%2F05%2F%E9%A2%98%E8%A7%A3-SP116-%E3%80%90INTERVAL-Intervals%E3%80%91%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 差分约束差分约束系统：由N个变量$X_1, X_2, X_3 …. X_N$和$M$个未知条件组成的N元一次不等式组，其中，每个条件都形如$X_i \le X_j + C_k$我们的问题是：给出一组满足所有条件的解，否则判断出无解 注意到，$X_i\le X_j + c_k$ 与单源最短路中的三角不等式很相似，建立N个节点对应N个变量。对于每组条件，从 j 向i连一条边。同时虚构0号节点并向每一个节点连一条边，如果存在负环则无解。否则有解。 问题转化那么，我们怎么根据这个题目建立起一个差分约束系统呢？我们可以用$siz[i]$表示区间$[0,i]$中被选的元素的个数，那么区间$[a_i,b_i]$中被选中的元素的个数我们就可以用$siz[b_i]-siz[a_i-1]$来表示。于是我们就可以从$a_i-1$向$b_i$连一条权值为$w$的有向边。另外，为了保证图的连通性，我们需要再从每一个数$a$向$a+1$连一条权为$0$的边，从每一个数$a$向$a-1$连一条权为$-1$的边。 那么，为什么这么连呢？ 因为$siz[a+1] -siz[a] \le 1$且$siz[a]-siz[a+1]\ge-1$。 最终的图是这个样子的（以该数据为例） code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;int x,y,z,n,cnt,ans,minn,maxx;int d[200005],vis[200005],dis[200005];struct edge&#123; int to,next,v;&#125;e[200005];void add(int x,int y,int z)&#123; e[++cnt].to = y; e[cnt].v = z; e[cnt].next = d[x]; d[x] = cnt;&#125;void clannad()&#123; for(int i = 0; i &lt;= cnt; i++) e[i].to = 0,e[i].next = 0,e[i].v = 0; for(int i = 0; i &lt;= cnt; i++) d[i] = 0; cnt = 0;&#125;queue&lt;int&gt; que;int spfa(int s)&#123; while(!que.empty()) que.pop(); for(int i = minn; i &lt;= maxx; i++) dis[i] = -INF; dis[s] = 0; memset(vis,0,sizeof(vis)); que.push(s); dis[s] = 0; vis[s] = 1; while(!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = 0; for(int i = d[u]; i; i = e[i].next) &#123; int v = e[i].to; int w = e[i].v; if(dis[v] &lt; dis[u] + w) &#123; dis[v] = dis[u] + w; if(!vis[v]) que.push(v),vis[v] = 1; &#125; &#125; &#125; return dis[maxx];&#125;int main()&#123; int t; t = read(); for(t; t &gt; 0; t--) &#123; n = read(); maxx = -INF; minn = INF; for(int i = 1; i &lt;= n; i++) &#123; x = read(); y = read(); z = read(); add(x - 1,y,z); maxx = max(y,maxx); minn = min(x - 1,minn); &#125; for(int i = minn; i &lt;= maxx; i++) &#123; add(i,i + 1,0); add(i + 1, i,-1); &#125; int ans = spfa(minn); printf("%d\n",ans); clannad(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[骑马修栅栏-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E9%AA%91%E9%A9%AC%E4%BF%AE%E6%A0%85%E6%A0%8F-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 我做的第一道欧拉路径的题说实话，这就一板子题…… 欧拉路径不会求的戳这里。 直接上代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define INF 0x7fffffff #define ll long long using namespace std; int n,m,x,y,head[1200],cnt,map[1030][1030],d[1030],begin,s[1030],t; void dfs(int k){ for(register int i = 1; i &lt;= n; i++) { if(map[k][i] &gt; 0) { map[k][i] –; map[i][k] –; dfs(i); } } s[++t] = k;} int main(){ scanf(“%d”,&amp;m); for(register int i = 1; i &lt;= m; i++) { scanf(“%d%d”,&amp;x,&amp;y); map[x][y] ++; map[y][x] ++; n = max(n,x); n = max(n,y); d[x] ++; d[y] ++; } for(register int i = 1; i &lt;= n; i++) { if(d[i] % 2 == 1) { begin = i; break; } } if(begin == 0) begin = 1; dfs(begin); for(register int i = t; i &gt;0; i–) printf(“%d\n”,s[i]); printf(“\n”); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[缺省源]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%BC%BA%E7%9C%81%E6%BA%90%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}int main(){ return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[菜肴制作-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E8%8F%9C%E8%82%B4%E5%88%B6%E4%BD%9C-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 一道明目张胆的拓扑排序的题目首先，由于题目给出“某些菜肴必须在另一些菜肴之前制作”这一条件，所以这道题可以用拓扑去做。其次，根据题目给出的“最优的菜肴制作顺序”的定义，我们自然而然的想到题目是让我们求字典序最小的拓扑序。 然而，这样做事错误的。出题人可以轻松把你卡掉，比如样例的第三组数据，答案是1 5 2 4 3，但是如果你是求的字典序最小的拓扑序，那么你求出的结果将会是1 4 3 5 2。很显然，2的位置靠后了。 既然求最小的字典序行不通，那么我们是不是可以反过来想呢？由于题目要求你把小的数尽量往前放，所以答案不一定是最小的字典序。但是，把小的数尽量往前方，那么大的数自然会尽量往后，这样一来，如果把拓扑序反过来，那么字典序最大的反拓扑序就一定是最优解。于是，我们可以建一个返图去求字典序最大的拓扑序，最后再倒序输出。 tip：为了优化时间复杂度，我们可以用堆去进行拓扑排序。 附一下代码： #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ll long long #define INF 0x7fffffff using namespace std; priority_queue&lt;int&gt;que; int t,n,m,x,cnt,d[100005],k[100005],ans[100005]; struct Edge{ int to,next;}edge[100005]; struct node{ int x,y;}u[100005]; void add(int x,int y){ edge[++cnt].to = y; edge[cnt].next = d[x]; d[x] = cnt; k[y] ++;} int mysort(node a,node b) {return a.y &lt; b.y;} void clean(){ while(!que.empty()) que.pop();} void work(){ for(register int i = 1; i &lt;= n; i++) if(k[i] == 0) que.push(i); while(!que.empty()) { x = que.top(); ans[++cnt] = x; que.pop(); for(register int i = d[x]; edge[i].to != 0; i = edge[i].next) { k[edge[i].to] –; if(k[edge[i].to] == 0) que.push(edge[i].to); } }} int main(){ scanf(“%d”,&amp;t); for(register int a = 1; a &lt;= t; a++) { cnt = 0; memset(d,0,sizeof(d)); memset(k,0,sizeof(k)); clean(); scanf(“%d%d”,&amp;n,&amp;m); for(register int i = 1; i &lt;= m; i++) scanf(“%d%d”,&amp;u[i].x,&amp;u[i].y); for(register int i = 1; i &lt;= m; i++) add(u[i].y,u[i].x); cnt = 0; work(); if(cnt &lt; n) printf(“Impossible!”); else for(register int i = n; i &gt;= 1; i–) printf(“%d “,ans[i]); printf(“\n”); } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[灾后重建-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%81%BE%E5%90%8E%E9%87%8D%E5%BB%BA-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 这道题目考查的就是对Folyd的灵活运用因为这题是需要你去求多元最短路，所以用Dijkstra或SPFA的话，时间复杂度显然是不可以接收的。 当然了，如果你直接用Floyd的话，也是会超时的。所以这道题就需要我们掌握Floyd的原理，才可以解决掉。 那么，我们该怎么去做呢？我们会发现，这道题目每个村庄修好的时间是不一致的，根据Floyd的思想，对于每一个新的查询时间t，我们只需要用在第k天修好的村庄去更新其它村庄的最短路即可。 在更新的过程中，我们会发现我们枚举的i，j两个点可能是尚未修复的，但这并没有关系，因为安照我们的算法思路，未被修复的村庄是不会被拿来更新其它村庄的距离的，而对于这两个村庄，我们只需要在读入时特判一下即可。 附一下代码： #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; #define INF 1000000000 using namespace std; int n,m,q,cnt,x,y,t,T,fi[300],head[300],map[300][300]; struct Edge{ int to,next,x;}edge[100005]; void floyd(int k){ for(register int i = 1; i &lt;= n; i++) for(register int j = 1; j &lt;= n; j++) map[i][j] = min(map[i][j],map[i][k] + map[k][j]);} int main(){ scanf(“%d%d”,&amp;n,&amp;m); for(register int i = 1; i &lt;= n; i++) for(register int j = 1; j &lt;= n; j++) map[i][j] = INF; for(register int i = 1; i &lt;= n; i++) scanf(“%d”,&amp;fi[i]); for(register int i = 1; i &lt;= m; i++) { scanf(“%d%d%d”,&amp;x,&amp;y,&amp;t); x ++; y ++; //个人习惯存的点的边号为1n，而题目给出的是0n-1 map[x][y] = t; map[y][x] = t; } scanf(“%d”,&amp;q); T = 0; for(register int a = 1; a &lt;= q; a++) { scanf(“%d%d%d”,&amp;x,&amp;y,&amp;t); x ++; y ++; while(t &gt;= fi[T + 1] &amp;&amp; T &lt; n) { T++; floyd(T); } if(fi[x] &gt; t || fi[y] &gt; t || map[x][y] == INF) { printf(“-1\n”); continue ; } printf(“%d\n”,map[x][y]); } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[车站分级-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E8%BD%A6%E7%AB%99%E5%88%86%E7%BA%A7-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题戳这里 一道有趣的建图题qxy当时做了好久才发现自己图建错了qwq看到“如果这趟车次停靠了火车站 x，则始发站、终点站之间所有级别大于等于火车站 x 的都必须停靠”后，大家有没有感到一丝丝熟悉呢？ 没错，这个条件和拓扑排序的条件很相似所以，我们只需要把所有的车站放到一个图中，在用一个类似于拓扑排序的算法去更新答案就可以了。 那么，具体该怎么建图呢？建图是这个题的难点，但其实原理非常简单。首先，对于每一班车，它提供的信息只对它的起点(a)到终点(b)这一段有效而并非对全部有效。其次，因为“如果这趟车次停靠了火车站 x，则始发站、终点站之间所有级别大于等于火车站 x 的都必须停靠”，所以在区间[a,b]中这趟车停过的点的级别一定高于没有停的点的级别。根据拓扑排序的要求，我们只需要从没有停下的点向每一个停下的点连一条有向边就可以了。ps：为了卡你，出题人一定对把图搞得很稠密，所以存图的时候需要优化一下时间复杂度。附一下代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; int head,tail,n,s,Max,t,m,c[1001],bus[1001],f[1001][1001],que[1001],d[1001],u[1001],stop[1001]; void work(){ while(head &lt; tail) { head++; for(int i = 1; i &lt;= n; i++) if(f[que[head]][i]) { d[i] –; u[i] = u[que[head]] + 1; Max = max(Max,u[i]); if(d[i] == 0) que[++tail] = i; } }} int main(){ scanf(“%d%d”,&amp;n,&amp;m); for(int i = 1; i &lt;= n; i++) u[i] = 0x7fffffff; for(int i = 1; i &lt;= m; i++) { scanf(“%d”,&amp;s); memset(c,0,sizeof(c)); t = 0; for(int j = 1; j &lt;= s; j++) scanf(“%d”,&amp;bus[j]); for(int j = 1; j &lt;= s; j++) c[bus[j]] = 1; for(int j = bus[1]; j &lt;= bus[s]; j++) if(!c[j]) stop[++t] = j; for(int j = 1; j &lt;= s; j++) for(int k = 1; k &lt;= t; k++) { if(!f[stop[k]][bus[j]]) //没连边 { f[stop[k]][bus[j]] = 1; d[bus[j]] ++; } } } for(int i = 1; i &lt;= n; i++) if(!d[i]) { que[++tail] = i; u[i] = 1; } work(); printf(“%d”,Max); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[钻石收藏家-two pointer]]></title>
    <url>%2F2019%2F08%2F02%2F%E9%92%BB%E7%9F%B3%E6%94%B6%E8%97%8F%E5%AE%B6-two%20pointer%2F</url>
    <content type="text"><![CDATA[有splay的标签其实用two-pointer就能轻松搞定时间复杂度为O(n)我们可以发现,将数据答案一定是数据的某两个区间的长度和。对于判断一个区间是否能够被放到一个架子上，只需要判断这个区间的首尾数据的差是否超过了k。 这里，我们可以用两个two-pointer来线性枚举区间，最后枚举这两个区间之间的分割点来更新答案。 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; using namespace std; int n,k,a[51000],l[51000],r[51000],p1,p2,maxx; int mysort(int a,int b) {return a &lt; b;} void two_pointer(){ p1 = 0; p2 = 1; for(int i = 1; i &lt;= n; i++) { p1 ++; while(a[p2] - a[p1] &lt;= k &amp;&amp; p2 &lt; n) p2 ++; if(a[p2] - a[p1] &gt; k) p2 – ; l[p1] = p2 - p1 + 1; }for(int i = n-1; i &gt; 0; i–) l[i] = max(l[i], l[i + 1]); //使用右侧的最优解更新当前节点} void tow_pointer(){ p1 = n + 1; p2 = n; for(int i = 1; i &lt;= n; i++) { p1 –; while(a[p1] - a[p2] &lt;= k &amp;&amp; p2 &gt; 1) p2 –; if(a[p1] - a[p2] &gt; k) p2 ++; r[p1] = p1 - p2 + 1; } for(int i = 2; i &amp;lt;= n; i++) r[i] = max(r[i], r[i - 1]);//使用右侧的最优解更新当前节点} int main(){ scanf(“%d%d”,&amp;n,&amp;k); for(int i = 1; i &lt;= n; i++) scanf(“%d”,&amp;a[i]); sort(a+1,a+n+1,mysort); two_pointer(); //枚举分割点右侧的区间 tow_pointer(); //枚举分割点左侧的区间 for(int i = 1; i &lt; n; i++) maxx = max(maxx, l[i + 1] + r[i]); //枚举分界点更新答案 cout &lt;&lt; maxx; return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[音乐会的等待-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E9%9F%B3%E4%B9%90%E4%BC%9A%E7%9A%84%E7%AD%89%E5%BE%85-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 感觉这道题用单调栈做这一点还是很容易看出来的。然后我们就会发现其实现在问题变得非常的简单。每次读入一个数，就找到第一个比它小的数并进行替换，然后将前面的数全部删掉就可以了，处理每一个数的时候都要更新一下答案。 附一下代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; long long n,top; long long Ans; int a[500050],stk[500050]; void dfs(int x) { int le=0,ri=top,mid,ret=0; while(le&lt;=ri) { mid=(le+ri)&gt;&gt;1; if(a[stk[mid]]&gt;x)ret=mid,le=mid+1; else ri=mid-1; } if(!ret)Ans+=top; else Ans+=top-ret+1; } int main() { scanf("%d",&amp;n); for(int i=1; i&lt;=n; ++i)scanf("%d",&amp;a[i]); for(int i=1; i&lt;=n; ++i) { dfs(a[i]); while(top&gt;0&amp;&amp;a[i]&gt;a[stk[top]])--top; stk[++top]=i; } printf("%lld",Ans); return 0; }]]></content>
  </entry>
  <entry>
    <title><![CDATA[晕牛-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%99%95%E7%89%9B-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 每错，这是一道拓扑排序的题。为什么这么说呢？因为拓扑排序的前提要求是进行排序的图必须是DAG。我们在看这道题的要求，就会发现，当你把所有双向边改成单向边以后，这个图就一定是一个DAG，否则一定无解。 呢么，我们该怎么进行拓扑排序呢？首先，对于给出的有向边，我们按照正常的拓扑排序的方式进行排序即可。 对于无向边，我们要双向连边，但是不更新入度。每当我们在拓扑排序是遍历到一条没有被处理过的双向边时，只需要把这条边的起点记录为当前正在遍历的节点即可。（想一想，为什么）· 附一下代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define INF 0x7fffffff #define ll long long using namespace std; struct Edge{ int from,to,next,del;}edge[2000005]; int t,a,b,n,p1,p2,head,tail,que[100001],d[100001],k[100001]; void add(int x,int y,int pd){ edge[++t].to = y; edge[t].from = x; edge[t].next = d[x]; d[x] = t; edge[t].del = pd;} int main(){ scanf(“%d%d%d”,&amp;n,&amp;p1,&amp;p2); for( int i = 1; i &lt;= p1; i++) { scanf(“%d%d”,&amp;a,&amp;b); add(a,b,0); k[b] ++; } if(t % 2 == 0) t++; for( int i = 1; i &lt;= n; i++) if(k[i] == 0) que[++tail] = i; for( int i = 1; i &lt;= p2; i++) { scanf(“%d%d”,&amp;a,&amp;b); add(a,b,1); add(b,a,1); } while(head &lt; tail) { head++; int u = que[head]; for( int i = d[u]; i; i = edge[i].next) { if(edge[i].del == 0) { k[edge[i].to] –; if(k[edge[i].to] == 0) que[++tail] = edge[i].to; } else if(edge[i].del == 1) edge[i^1].del = 2; } } for( int i = 1;i &lt;= t; i++) if(edge[i].del == 1) printf(“%d %d\n”,edge[i].from,edge[i].to); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[最接近的分数-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%88%86%E6%95%B0-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 emmmmm…… 感觉这道题就是一个暴力…… 首先，由于n和m的范围都很大，所以直接枚举n和m会超时，所以我们需要换一种思路，那就是之枚举一个。 因为我们要使x/y的值与a的值最接近，所以当x/y = a时，x = a * y，所以我们只需要枚举y的值即可。 由于实数转整数的时候比较迷，所以我们要分别向上和向下取整 ps：别忘了TOO MANY的特判 附一下代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define re register #define INF 0x7fffffff #define ll long long using namespace std; int read(){ int x = 0,f = 1; char ch; ch = getchar(); while(ch &gt;’9’ || ch &lt; ‘0’){if(ch == ‘-‘) f = -f; ch = getchar();} while(ch &gt;= ‘0’ &amp;&amp; ch &lt;= ‘9’){x = x * 10 + ch - ‘0’; ch = getchar();} return x * f;} int gcd(int a, int b){return a == 0 ? b : gcd(b % a, a);} int n,m,x,u,pd,g,oo; double a,k,Min = INF,j,te; int work1(int i){ k = a * i; u = k; k = u + 1; te = k / i; j = fabs((k / i) - a);} int work2(int i){ k = a * i; u = k; k = u; te = k / i; j = fabs((k / i) - a);} int main(){ m = read(); n = read(); cin &gt;&gt; a; for(re int i = 1; i &lt;= n; i++) { work1(i); if(j &amp;lt; Min &amp;amp;&amp;amp; u &amp;lt;= m) { Min = j; x = i; pd = 0; oo = te * x; } work2(i); if(j == Min &amp;amp;&amp;amp; u &amp;lt;= m) pd = 1; if(j &amp;lt; Min &amp;amp;&amp;amp; u &amp;lt;= m) { Min = j; x = i; pd = 0; oo = te * x; } } if(a &amp;lt; 0.5&amp;amp;&amp;amp; (m &amp;lt; 2 || n &amp;lt; 2)) { printf(&quot;TOO MANY\n&quot;); return 0; } double ans1 = a * x,ans2 = a * x + 1; int ans = ans1; ans2 = ans; if(fabs(ans2/x - a) &amp;gt; fabs((ans2 + 1)/x - a)) ans ++; g = gcd(x,ans); if(g ==0) g = 1; if(x == 0) { cout &amp;lt;&amp;lt;&quot;1/1&quot;&amp;lt;&amp;lt; endl; return 0; } printf(&quot;%d/%d\n&quot;,ans / g, x / g); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[星球大战-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%98%9F%E7%90%83%E5%A4%A7%E6%88%98-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 我没看过电影qwq…… 刚开始看到这个题，觉着可以用Floyd去做，时间复杂度为n^3…… 于是…… 我们还是用并查集好了当然了，如果我们在每次删去一个点后就跑一遍并查集去统计联通块的数量，那么一定会超时的。 所以，我们要用另一种方法…… 倒着做！然后，我们先把所有将被干掉的星球的状态都先记为死亡，然后一个个的复活并用所有与该点有关的边去更新联通块的数量。 附一下代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define INF 0x7fffffff #define ll long long using namespace std; int n,m,cnt,k,x,y,f[400005],head[400005],kill[400005],live[400005],ans[400005]; struct Edge{ int to,next;}edge[400005]; void add(int a,int b){ edge[++cnt].to = b; edge[cnt].next = head[a]; head[a] = cnt;} int find(int x){ if(f[x] == x) return x; return f[x] = find(f[x]);} void work(int x,int y){ if(find(x) != find(y)) f[find(x)] = f[find(y)];} int main(){ scanf(“%d%d”,&amp;n,&amp;m); for(register int i = 1; i &lt;= n; i++) f[i] = i; for(register int i = 1; i &lt;= m; i++) { scanf(“%d%d”,&amp;x,&amp;y); x ++; y ++; add(x,y); add(y,x); } scanf(“%d”,&amp;k); for(register int i = k; i &gt; 0; i–) { scanf(“%d”,&amp;kill[i]); kill[i] ++; live[kill[i]] = 1; } cnt = n; for(register int i = 1; i &lt;= n; i++) if(!live[i]) for(register int j = head[i]; j; j = edge[j].next) if(!live[edge[j].to]) if(find(i) != find(edge[j].to)) { cnt –; work(i,edge[j].to); } cnt = cnt - k; ans[1] = cnt; for(register int i = 1; i &lt;= k; i++) { live[kill[i]] = 0; cnt ++; for(register int j = head[kill[i]]; j; j = edge[j].next) if(!live[edge[j].to]) if(find(kill[i]) != find(edge[j].to)) { cnt –; work(kill[i],edge[j].to); } ans[i + 1] = cnt; } for(register int i = k + 1; i &gt; 0; i–) printf(“%d\n”,ans[i]); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[无序字母对-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%97%A0%E5%BA%8F%E5%AD%97%E6%AF%8D%E5%AF%B9-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看题目请戳这里 又一道欧拉回路的裸题把字母hash一下，然后跑一个欧拉回路就可以轻松搞定。 不会欧拉回路的戳这里。 附一下代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define INF 0x7fffffff #define ll long long using namespace std; int n,m,x,y,tj,begin = INF,t,map[1000][1000],d[1000],sta[1000]; char s[2]; int getint(char c){ if(c &lt; ‘a’) return c - ‘A’ + 1; return c - ‘a’ + 27;} char getcha(int c){ if(c &lt;= 26) return c + ‘A’ - 1; return c + ‘a’ - 27;} void dfs(int k){ for(register int i = 1; i &lt;= n; i++) { if(map[k][i] &gt; 0) { map[k][i] = 0; map[i][k] = 0; dfs(i); } } sta[++t] = k;} int main(){ scanf(“%d”,&amp;m); for(register int i = 1; i &lt;= m; i++) { cin &gt;&gt; s; x = getint(s[0]); y = getint(s[1]); n = max(x,n); n = max(y,n); begin = min(begin,x); begin = min(begin,y); map[x][y] = 1; map[y][x] = 1; d[x] ++; d[y] ++; } for(register int i = 1; i &lt;= n; i++) if(d[i] % 2 == 1) tj ++; if(tj == 1 || tj &gt;2) { printf(“No Solution\n”); return 0; } for(register int i = 1; i &lt;= n; i++) { if(d[i] % 2 == 1) { begin = i; break; } } dfs(begin); int k = begin; for(register int i = t; i &gt;0; i–) cout &lt;&lt; getcha(sta[i]); cout &lt;&lt; endl; return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[离散化-学习]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%A6%BB%E6%95%A3%E5%8C%96-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[·什么是离散化？离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。 ·为什么要用、什么时候要用离散化呢？如果让你吧1000个1到1000的数放到桶里，那么非常简单，直接开一个大小为1000的数组，然后在里面统计就可以了。但是，如果吧这1000个数的大小改为1到1000000000呢？很显然，直接开一个大小为1000000000的数组去统计是不现实的，直接MLE。这时，我们就需要用到离散化了。（当然，这只是一个小例子） ·我们怎么去实现离散化呢？对于一个数组a，我们可以用另外一个数组去记录其中每个数的大小关系（如数字b在a中为第k大），这样就可以在新得到的数组中查询每个数的大小关系。这样，我们就达到了离散化的目的。而且，我们可以利用这个大小关系来得到之前原数组对应位置的数字。 ·具体该怎么用代码实现呢？为了实现离散化，我们需要用到unique和lower_bound这两个函数。 uniqueunique可以统计某数组中不同元素的个数，如我们想用cnt去记录长度为n的数组a中有几个不同的元素，则可以用到unique，代码为 cnt = unique(a + 1, a + n + 1) - a - 1lower_bound其实还有一个叫upper_bound的函数 lower_bound可以返回某个元素在某个数组中是第几大的。例如，如你想用ans去记录数字b在长度为n数组a中是第几大的，那么就可以通过lower_bound去实现，代码为 ans = lower_bound(a + 1, a + n + 1, b) - a;附一下完整代码： 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,cnt,ans,a[1000],b[1000],x[1000];int mysort(int a,int b) {return a &lt; b;}int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; //输入 for(int i = 1; i &lt;= n; i++) x[i] = a[i]; //用x记录a，方便后续操作 sort(x + 1, x + n + 1, mysort); //排序 对于统计来书可有可无，但方便去重和还原 cnt = unique(x + 1, x + n + 1) - x - 1; //统计x中不同颜色的个数 for(int i = 1; i &lt;= n; i++) b[i] = lower_bound(x + 1, x + n + 1, a[i]) - x; //统计每个元素在原数组的大小位置 cout &lt;&lt; "cnt = " &lt;&lt; cnt &lt;&lt; endl; //查看不同元素的个数 for(int i = 1; i &lt;= n; i++) cout &lt;&lt; b[i] &lt;&lt; " "; //查看离散化后的数组 cout &lt;&lt; endl; for(int i = 1; i &lt;= n; i++) cout &lt;&lt; x[b[i]] &lt;&lt; " "; //还原数组a cout &lt;&lt; endl; return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[数字权重-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%95%B0%E5%AD%97%E6%9D%83%E9%87%8D-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题 一道非常简单的数论题为什么说它非常简单呢？可能大家刚开始看到那个式子会有点懵，但是如果你把求和函数展开就会发现，式子会变为 a[n] - a[n-1] + a[n-1] - a[n-2] + … +a[2] - a[1]然后你就会发现这个求和函数的值只与an与a1的值有关…… 于是这个题一下就简单很多了。那么，具体该怎么做呢？首先，既然这个式子的值与a[n]与a[1]的差有关，由于k的范围只能为 -9 ~ 8 ，我们完全可以打一张表出来（其实等表打出来了，规律也就一目了然了）。至于剩下的 n - 2 位，它们的值可以是 0 ~ 9 之间的任何一个数字。于是中间每多一位，就会使ans * 10。 附一下代码： #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; using namespace std; long long ksm(long long x,long long y,long long mod) //快速幂，不会的自己去百度{ long long ans = 1; while(y &gt; 0) { if(y &amp; 1) ans = (ans * x) % mod; x = (x * x) % mod; y = y &gt;&gt; 1; } return ans % mod;} int main(){ long long mod = 1000000007, n, k, ans; cin &gt;&gt; n &gt;&gt; k; long long a = 9 - abs(k); if(k &lt; 0) a++; if(k &gt;= 9 || k &lt; -9) //特判，k在此情况下方案数一定为0 { cout &lt;&lt;0&lt;&lt; endl; return 0; } cout &lt;&lt; (a * ksm(10, n - 2, mod)) % mod &lt;&lt; endl; return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[局域网-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%B1%80%E5%9F%9F%E7%BD%91-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看题目戳这里 一道最小生成树的裸题，这里我们用kruskal来做kruskal 是一种求最小生成树的算法，时间复杂度为O(nlogn)它的算法思路是这样的：我们根据边的权值将所有边排序，然后枚举每条边，用并查集去查询这条边的两个端点是否在同一集合内，若在同一集合内，则删掉这条边，若不在同一结合则加入这条边，并将这两个端点所在的集合合并。附一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,m,q[6000];struct lalala{ int x,y,z,save;}a[210000];int mysort(lalala a,lalala b){ return a.z &lt; b.z;}int work(int x,int y){ while(q[q[x]] != q[x]) q[x] = q[q[x]]; while(q[q[y]] != q[y]) q[y] = q[q[y]]; if(q[x] == q[y]) return 1; else { q[q[y]] = q[x]; return 0; }}int main(){ long long ans = 0; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) q[i]=i; for(int i=1; i&lt;=m; i++) { cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].z; ans += a[i].z; } sort(a+1,a+m+1,mysort); for(int i=1;i&lt;=m;i++) { if(!work(a[i].x,a[i].y)) ans -= a[i].z; } cout &lt;&lt; ans; return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[导弹拦截-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 一道经典dp题……它有两问，第一问是一个裸的最长不上升子序列，不会的戳这里。 至于第二问，非常简单，做法也有很多，像最长上升子序列、贪心、模拟…… 附一下代码： #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #define INF 0x7fffffff using namespace std; int n,a[100005],sta[100005],t; void two_fen(int k){ int l = 1, r = t, mid; while(l &lt;= r) { mid = (l + r) &gt;&gt; 1; if(sta[mid] &gt;= k) l = mid + 1; else r = mid - 1; } sta[l] = k;} void work(){ sta[0] = INF; t = 0; for(int i = 1; i &lt;= n; i++) { if(a[i] &lt;= sta[t]) sta[++t] = a[i]; else two_fen(a[i]); } //for(int i = 1; i &lt;= t; i++) cout &lt;&lt; sta[i] &lt;&lt; “ “;cout &lt;&lt;endl; printf(“%d\n”,t);} void count(){ memset(sta,0,sizeof(sta)); int j,place,x; t = 0; for(int i = 1; i &lt;= n; i++) { place = 0; x = INF; for(int j = 1; j &lt;= t; j++) if(sta[j] &gt;= a[i] &amp;&amp; (sta[j] &lt; sta[place] || place == 0)) place = j; if(place == 0) sta[++t] = a[i]; else sta[place] = a[i]; } printf(“%d\n”,t);} int main(){ while(cin &gt;&gt; a[++n]); n –; work(); count(); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[寻找最优美做题曲线]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%AF%BB%E6%89%BE%E6%9C%80%E4%BC%98%E7%BE%8E%E5%81%9A%E9%A2%98%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[查看题目戳这里 一道最长上升子序列的裸题由题目描述可以看出，我们选择的日期中每天做题数量一定是递增的。这样，我们就能很轻易地想到用最长上升子序列去完成这道题。在这里，由于数据范围较大，我们需要用nlogn的算法去完成这道题。 那么，怎么去处理这必须做题的k天呢？由于这k天做题数量一定是最长上升子序列的一部分，这样我们就可以发现有某些天是一定不能选的。当我们把这些一定不能选的日期删掉后就会发现，只要我们按照正常的算法去求最长上升子序列，那么这k天一定是包含在里面的。（想一想，为什么）至于判断是否有最长上升子序列，只需要判读这必选的k天是否单调上升即可。附一下代码： #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; using namespace std; int n,k,cnt,t,a[500005],c[250005],sta[500005]; int mysort(int a,int b) {return a &lt; b;} int judge(){ sort(c + 1, c + k + 1, mysort); for(int i = 2; i &lt;= k; i++) if(a[c[i]] &lt;= a[c[i - 1]]) { printf(“impossible”); return 1; } return 0;} void clean(){ for(int i = 1; i &lt; c[1]; i++) if(a[i] &gt;= a[c[1]]) a[i] = -1; for(int i = 1; i &lt; k; i++) for(int j = c[i] + 1; j &lt;= c[i + 1] - 1; j++) if(a[j] &lt;= a[c[i]] || a[j] &gt;= a[c[i + 1]]) a[j] = -1; for(int i = c[k] + 1; i &lt;= n; i++) if(a[i] &lt;= a[c[k]]) a[i] = -1; for(int i = 1; i &lt;= n; i++) if(a[i] != -1) a[++cnt] = a[i];} void two_fen(int k){ int l = 1,r = t,mid; while(l &lt;= r) { mid = (l + r) &gt;&gt; 1; if(sta[mid] &lt; k) l = mid + 1; else r = mid - 1; } sta[l] = k;} void work(){ sta[0] = -1008611; for(int i = 1; i &lt;= cnt; i++) { if(a[i] &gt; sta[t]) sta[++t] = a[i]; else two_fen(a[i]); } printf(“%d\n”,t);} int main(){ scanf(“%d%d”,&amp;n,&amp;k); for(int i = 1; i &lt;= k; i++) scanf(“%d”,&amp;c[i]); for(int i = 1; i &lt;= n; i++) scanf(“%d”,&amp;a[i]); if(judge()) return 0; clean(); work(); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[回文分割-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%9B%9E%E6%96%87%E5%88%86%E5%89%B2-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 思路我们可以对读入的字符串s任意排序，但是实际上我们并没有必要对s进行排序——aabbaa和baaaab其实对于这道题来讲是一样的。我们可以发现，对于数量为偶数的字母，我们将其中的偶数个分别添加到某个回文串的两侧，这样就可以得到一个更长的回文串。而且，每个回文串中至多有一个字母在本回文串的个数为1。这就意味着，若数量为奇数的字母有n个，则我们至少需要把s分成n个回文串。因此，奇数影响着回文串的个数，偶数影响回文串的长度。所以，我们只需要记录每一个字母的出现次数即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}char s[1000005]; int t[100],j,o;int main(){ cin &gt;&gt; s; int l = strlen(s); for(int i = 0; i &lt; l; i++) t[s[i] - 'a' + 1] ++; for(int i = 1; i &lt;= 26; i++) { j = j + t[i] % 2; o = o + t[i] / 2; } int ans; if(j) ans = o / j * 2 + 1; else ans = o * 2; cout &lt;&lt; ans &lt;&lt; endl; return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[线性代数]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hash-学习]]></title>
    <url>%2F2019%2F08%2F02%2FHash-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[基本概念Hash，一般翻译做“散列”，也有直接音译为“哈希”的。那么哈希函数的是什么样的？大概就是 value = hash(key)，我们希望key和value之间是唯一的映射关系。 大家使用的最多的就是哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构，通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做哈希函数或散列函数。 实际中的Hash主要有两种应用：加密和压缩。在加密方面，Hash哈希是把一些不同长度的信息转化成杂乱的128位的编码,这些编码值叫做HASH值，最广泛应用的Hash算法有MD4、MD5、SHA1。在压缩方面，Hash哈希是指把一个大范围映射到一个小范围，往往是为了节省空间，使得数据容易保存。 当然了，在我们做题的过程中，使用到的hash的方法都是十分简单的。 Hash的特点 主要原理就是把大范围映射到小范围，因此输入范围必须和小范围相当或者比它更小，否则增加冲突。 Hash函数逼近单向函数，所以可以用来对数据进行加密。（单项函数：如果某个函数在给定输入的时候，很容易计算出其结果来；而当给定结果的时候，很难计算出输入来） 不同的应用对Hash函数有着不同的要求：用于加密的Hash函数主要考虑它和单项函数的差距，而用于查找的Hash函数主要考虑它映射到小范围的冲突率。 具体实现Hash的方法非常多，有用加法的，有用乘法的，有用位运算的，还有混合的。这里，为了尽可能减小冲突的可能性，我们选择用混合运算去Hash。 Hash的具体思路就是把一串字符计算后形成一个数字。我们直接来看一段Hash的代码来理解吧： #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define ll long long #define INF 0x7fffffff using namespace std; int hash(char s[]){ int h = 0, l = strlen(s), k; for(register int i = 0; i &lt; l; i++) { k = s[i]; h = (h * 31 + k &lt;&lt; 1) % 23456789; } return h;} char s[1000]; int main(){ while(1) { cin &gt;&gt;s; cout &lt;&lt;hash(s) &lt;&lt; endl; } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[飞行路线-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E9%A3%9E%E8%A1%8C%E8%B7%AF%E7%BA%BF-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 一道分层图最短路的裸题分层图最短路不会的戳这里 这道题实在是太裸了，我都不知道该在说写什么了（你把分层图最短路的版子交上去貌似都能过……） 附一下代码： #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ll long long #define INF 2147483647 using namespace std; struct node{ int k,dis,used; bool operator &lt; ( const node &amp;x )const{return x.dis &lt; dis;}}; priority_queue&lt;node&gt; que; long long n,m,k,s,t,d[50005],cnt,D[50005][15],v[50005][15]; struct Edge{ int to,next,x;}edge[2000005]; void add(int x,int y,int a){ edge[++cnt].to = y; edge[cnt].x = a; edge[cnt].next = d[x]; d[x] = cnt;} int main(){ int x,y,a; scanf(“%lld%lld%lld”,&amp;n,&amp;m,&amp;k); scanf(“%d%d”,&amp;s,&amp;t); s ++; t ++; for(register int i = 1; i &lt;= m; i++) { scanf(“%d%d%d”,&amp;x,&amp;y,&amp;a); x ++; y ++; add(x,y,a); add(y,x,a); } que.push((node){s,0,0}); for(register int i = 0; i &lt;= n; i++) for(register int j = 0; j &lt;= k; j++) D[i][j] = INF; D[s][0] = 0; while(!que.empty()) { node u = que.top(); que.pop(); int kk = u.k,level = u.used; if(v[u.k][u.used]) continue; v[u.k][u.used] = 1; for(register int i = d[kk]; i; i = edge[i].next) { int too = edge[i].to; if(D[too][level] &amp;gt; D[kk][level] + edge[i].x) { D[too][level] = edge[i].x + D[kk][level]; que.push((node){too,D[too][level],level}); } if(level &amp;lt; k &amp;amp;&amp;amp; D[too][level + 1] &amp;gt; D[kk][level]) { D[too][level + 1] = D[kk][level]; que.push((node){too,D[too][level + 1],level + 1}); } } } long long ans = INF; for(register int i = 0; i &amp;lt;= k; i++) ans = min(ans,D[t][i]); printf(&quot;%lld\n&quot;,ans); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[糖果传递-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%B3%96%E6%9E%9C%E4%BC%A0%E9%80%92-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里怎么说呢，这道题貌似需要用式子来表示出每个小盆友的代价，才可以理解这道题的做法。对于每一个小盆友，他最终的糖果数是一定要等于平局数的。所以，我们用a表示小盆友原有的糖果，xn表示他给上一个小盆友的苹果数，x(n + 1)表示他的下一个小盆友给他的糖果数，则有： 对于第1个小朋友，A1-X1+X2=ave -&gt; X2=ave-A1+X1 = X1-C1(假设C1=A1-ave，下面类似） 对于第2个小朋友，A2-X2+X3=ave -&gt; X3=ave-A2+X2=2ave-A1-A2+X1=X1-C2 对于第3个小朋友，A3-X3+X4=ave -&gt; X4=ave-A3+X3=3ave-A1-A2-A3+X1=X1-C3 …… 对于第n个小朋友，An-Xn+X1=ave。 至于如何确定X1的值，我们去中位数即可。(不懂的可以看货仓选址问题）附一下代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define INF 0x7fffffff #define ll long long using namespace std; ll n,a[1000005],ans,sum,p,s[1000005]; int main(){ scanf(“%lld”,&amp;n); for(register int i = 1; i &lt;= n; i++) { scanf(“%lld”,&amp;a[i]); sum += a[i]; } p = sum / n; for(register int i = 1; i &lt;= n; i++) a[i] -= p; for(register int i = 1; i &lt;= n; i++) s[i] = s[i - 1] + a[i]; sort(s + 1, s + n + 1); int t = s[(n + 1) &gt;&gt; 1]; for(register int i = 1; i &lt;= n; i++) ans += fabs(t - s[i]); printf(“%lld”,ans); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[冻结-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%86%BB%E7%BB%93-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 又是一道分层图最短路的裸题分层图最短路不会的戳这里 这道题之需要把分层图最短路的方程稍微改一下就可以了。 附一下代码： #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ll long long #define INF 2147483647 using namespace std; struct node{ int k,dis,used; bool operator &lt; ( const node &amp;x )const{return x.dis &lt; dis;}}; priority_queue&lt;node&gt; que; long long n,m,k,s,t,d[50005],cnt,D[50005][60],v[50005][60]; struct Edge{ int to,next,x;}edge[2000005]; void add(int x,int y,int a){ edge[++cnt].to = y; edge[cnt].x = a; edge[cnt].next = d[x]; d[x] = cnt;} int main(){ int x,y,a; scanf(“%lld%lld%lld”,&amp;n,&amp;m,&amp;k); s = 1; t = n; for(register int i = 1; i &lt;= m; i++) { scanf(“%d%d%d”,&amp;x,&amp;y,&amp;a); add(x,y,a); add(y,x,a); } que.push((node){s,0,0}); for(register int i = 0; i &lt;= n; i++) for(register int j = 0; j &lt;= k; j++) D[i][j] = INF; D[s][0] = 0; while(!que.empty()) { node u = que.top(); que.pop(); int kk = u.k,level = u.used; if(v[u.k][u.used]) continue; v[u.k][u.used] = 1; for(register int i = d[kk]; i; i = edge[i].next) { int too = edge[i].to; if(D[too][level] &amp;gt; D[kk][level] + edge[i].x) { D[too][level] = edge[i].x + D[kk][level]; que.push((node){too,D[too][level],level}); } if(level &amp;lt; k &amp;amp;&amp;amp; D[too][level + 1] &amp;gt; D[kk][level] + edge[i].x / 2) { D[too][level + 1] = D[kk][level] + edge[i].x / 2; que.push((node){too,D[too][level + 1],level + 1}); } } } long long ans = INF; for(register int i = 0; i &amp;lt;= k; i++) ans = min(ans,D[t][i]); printf(&quot;%lld\n&quot;,ans); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[关押罪犯-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%85%B3%E6%8A%BC%E7%BD%AA%E7%8A%AF-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 qxy做的第一道种类并查集的题目种类并查集不会的戳这里 这道题基本上就是一个种类并查集的板子题，于是我们直接附一下代码好了： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define INF 0x7fffffff #define ll long long using namespace std; int n,m,a,b,v,q,f[40005]; struct person{ int x,y,w;}p[100005]; int mysort(person x,person y){ return x.w &gt; y.w;} int find(int x){ if(f[x] == x) return x; return f[x] = find(f[x]);} int main(){ scanf(“%d%d”,&amp;n,&amp;m); for(register int i = 1; i &lt;= n; i++) { f[i] = i; f[i + n] = i + n; } for(register int i = 1; i &lt;= m; i++) scanf(“%d%d%d”,&amp;p[i].x,&amp;p[i].y,&amp;p[i].w); sort(p + 1, p + m + 1, mysort); for(register int i = 1; i &lt;= m; i++) { a = p[i].x; b = p[i].y; v = p[i].w; if(find(a) == find(b) || find(a + n) == find(b + n)) { cout &lt;&lt; p[i].w; return 0; } f[find(a)] = f[find(b + n)]; f[find(b)] = f[find(a + n)]; } printf(“0”); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ant Trip-题解]]></title>
    <url>%2F2019%2F08%2F02%2FAnt%20Trip-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里因为每条边都只能走一次，所以这道题可以用欧拉路的性质来求解。我们首先用并查集去记录每一个联通块，然后再统计每一个子图的奇点数，如果是偶数则满足欧拉回路的性质直接ans++ 就好了，如果是奇数，那么需要的蚂蚁数则是奇点数/2附一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re register using namespace std;int read(){ register int a = 0,f = 1; register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0') {if(ch == '-') f = -1; ch = getchar();} while(ch &lt;='9' &amp;&amp; ch &gt;='0') {a = a * 10 + ch - 48; ch = getchar();} return a * f;}int n,m,x,y,s,ans,cnt,t,d[100005],fa[100005],use[100005],a[100005],add[100005];int find(int p){ if(fa[p] == p) return p; return fa[p] = find(fa[p]);}void work(){ m = read(); ans = 0; for(re int i = 1; i &lt;= n; i++) fa[i] = i; for(re int i = 1; i &lt;= n; i++) d[i] = 0; for(re int i = 1; i &lt;= n; i++) a[i] = 0; for(re int i = 1; i &lt;= n; i++) add[i] = 0; for(re int i = 1; i &lt;= m; i++) { x = read(); y = read(); d[x] ++; d[y] ++; if(find(x) != find(y)) fa[find(y)] = find(x); } for(int i = 1; i&lt;= n; i++) { a[find(i)]++; if(d[i] % 2 == 1) add[find(i)] ++; } for(int i = 1; i &lt;= n; i++) { if(a[i] &lt;= 1) continue; //只有一个点和空的点集没有边，可以忽略不计。 else if(add[i] == 0) ans += 1; else if(add[i] &gt; 0) ans += add[i]/2; } cout &lt;&lt; ans &lt;&lt; endl;}int main(){ while(cin &gt;&gt; n) work(); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra-学习]]></title>
    <url>%2F2019%2F08%2F02%2FDijkstra-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言SPFA算法由于它上限O(NM)的时间复杂度,被卡掉的几率很大.在算法竞赛中,我们需要一个更稳定的算法:dijkstra 什么是dijkstra?dijkstra是一种单源最短路径算法,时间复杂度上限为O(n^2)(朴素),在实际应用中较为稳定;加上堆优化之后更是具有O((n+m)log^2 n)的时间复杂度,在稠密图中有不俗的表现. dijkstra的原理/流程?dijkstra本质上的思想是贪心,它只适用于不含负权边的图.我们把点分成两类,一类是已经确定最短路径的点,称为”白点”,另一类是未确定最短路径的点,称为”蓝点” dijkstra的流程如下: 初始化dis[start] = 0,其余节点的dis值为无穷大. 找一个dis值最小的蓝点x,把节点x变成白点. 遍历xx的所有出边(x,y,z)，若dis[y] &gt; dis[x] + z,则令dis[y] = dis[x] + z 重复2,3两步,直到所有点都成为白点.dijkstra为什么是正确的当所有边长都是非负数的时候,全局最小值不可能再被其他节点更新.所以在第2步中找出的蓝点x必然满足:dis[x]已经是起点到x的最短路径.我们不断选择全局最小值进行标记和拓展,最终可以得到起点到每个节点的最短路径的长度图解(令start = 1)开始时我们把dis[start]初始化为0,其余点初始化为inf第一轮循环找到dis值最小的点1,将1变成白点,对所有与1相连的蓝点的dis值进行修改,使得dis[2]=2,dis[3]=4,dis[4]=7第二轮循环找到dis值最小的点2,将2变成白点,对所有与2相连的蓝点的dis值进行修改,使得dis[3]=3,dis[5]=4第三轮循环找到dis值最小的点3,将3变成白点,对所有与2相连的蓝点的dis值进行修改,使得dis[4]=4接下来两轮循环分别将4,5设为白点,算法结束,求出所有点的最短路径 为什么dijkstra不能处理有负权边的情况?我们来看下面这张图2到3的边权为−4,显然从1到3的最短路径为−2 (1-&gt;2-&gt;3).但在循环开始时程序会找到当前dis值最小的点3,并标记它为白点.这时的dis[3]=1,然而1并不是起点到3的最短路径.因为3已经被标为白点,所以dis[3]不会再被修改了.我们在边权存在负数的情况下得到了错误的答案. dijkstra的堆优化?观察dijkstra的流程,发现步骤2可以优化怎么优化呢?我们可以用堆对disdis数组进行维护,用O(logn)的时间取出堆顶元素并删除,用O(logn)的时间遍历每条边,总复杂度O((n+m)\log^2 n).附一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll long long#define INF 2147483647using namespace std;struct node{ int k,dis; bool operator &lt; ( const node &amp;x )const{return x.dis &lt; dis;}};priority_queue&lt;node&gt; que;long long n,m,s,d[1000005],cnt,D[1000005],v[1000005]; struct Edge{ int to,next,x;}edge[2000005];void add(int x,int y,int a){ edge[++cnt].to = y; edge[cnt].x = a; edge[cnt].next = d[x]; d[x] = cnt;}int main(){ int x,y,a; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;s); for(register int i = 1; i &lt;= m; i++) { scanf("%d%d%d",&amp;x,&amp;y,&amp;a); add(x,y,a); } que.push((node){s,0}); for(register int i = 1; i &lt;= n; i++) D[i] = INF; D[s] = 0; while(!que.empty()) { node u = que.top(); que.pop(); if(v[u.k]) continue; v[u.k] = 1; for(register int i = d[u.k]; i; i = edge[i].next) { if(D[edge[i].to] &gt; D[u.k] + edge[i].x) { D[edge[i].to] = edge[i].x + D[u.k]; if(!v[edge[i].to]) que.push((node){edge[i].to,D[edge[i].to]}); } } } for(register int i = 1; i &lt;= n; i++) printf("%d ",D[i]); printf("\n"); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[Largest Rectangle in a Histogram-题解]]></title>
    <url>%2F2019%2F08%2F02%2FLargest%20Rectangle%20in%20a%20Histogram-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里我们用单调栈来维护每一个小矩形的左侧和右侧第一个比它低的矩形的位置。为什么要维护这个呢？根据木桶原理，每一个大矩形的高度是由其高度最小的矩形的高度决定的，所以我们要去记录第一个比当前矩形小的矩形的位置。ps：别忘了初始化qwq……附一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re register#define pie 3.1415926using namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}int n,t,q,l[100005],r[100005],sta[100005],p;struct build{ int x,h;}b[100005];void init1(int k){ if(p == 0) { sta[++p] = k; return ; } if(b[k].h &gt;= b[sta[p]].h) { sta[++p] = k; return ; } while(b[sta[p]].h &gt; b[k].h &amp;&amp; p) { l[sta[p]] = k; p --; } sta[++p] = k;}void init2(int k){ if(p == 0) { sta[++p] = k; return ; } if(b[k].h &gt;= b[sta[p]].h) { sta[++p] = k; return ; } while(b[sta[p]].h &gt; b[k].h &amp;&amp; p) { r[sta[p]] = k; p --; } sta[++p] = k;}ll ans;int main(){ n = read(); while(n != 0) { ans = 0; memset(b,0,sizeof(b)); for(int i = 1; i &lt;= n; i++) { b[i].h = read(); b[i].x = i; } p = 0; for(int i = 1; i &lt;= n + 1; i++) init1(i); p = 0; for(int i = n; i &gt;= 0; i--) init2(i); for(int i = 1; i &lt;= n; i++) { ans = max(ans,1LL * (l[i] - r[i] - 1) * b[i].h); } printf("%lld\n",ans); n = read(); } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[分层图最短路-学习]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%88%86%E5%B1%82%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[ARX：我今天上午做了两个分层图最短路的题，可简单了……概念 分层图最短路是指在可以进行分层图的图上解决最短路问题。一般模型是：在图上，有k次机会可以直接通过一条边，问起点与终点之间的最短路径。 算法思路这是一个类似于DP的思路。用直接通过的边把整个图分成k个子图，其中k为可以直接通过的边的个数。在此基础上，我们直接跑最短路算法就可以了。 算法细节在处理子图与子图之间的关系时，由于连接两个子图的路径是可以直接通过的，所以我们在记录下一层的路径长度时，转移方程为:if(d[edge[i].to][level + 1] &lt; d[u][level] &amp;&amp; level &lt; k) d[edge[i].to][level + 1] = d[u][level];其中edge[i]是一条以节点u为起点的边。注意，由于图的层数有限，所以level &lt; k这一条件一定不要忘记加。附一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll long long#define INF 2147483647using namespace std;struct node{ int k,dis,used; bool operator &lt; ( const node &amp;x )const{return x.dis &lt; dis;}};priority_queue&lt;node&gt; que;long long n,m,k,s,t,d[50005],cnt,D[50005][15],v[50005][15]; struct Edge{ int to,next,x;}edge[2000005];void add(int x,int y,int a){ edge[++cnt].to = y; edge[cnt].x = a; edge[cnt].next = d[x]; d[x] = cnt;}int main(){ int x,y,a; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k); scanf("%d%d",&amp;s,&amp;t); for(register int i = 1; i &lt;= m; i++) { scanf("%d%d%d",&amp;x,&amp;y,&amp;a); add(x,y,a); add(y,x,a); } que.push((node){s,0,0}); for(register int i = 0; i &lt;= n; i++) for(register int j = 0; j &lt;= k; j++) D[i][j] = INF; D[s][0] = 0; while(!que.empty()) { node u = que.top(); que.pop(); int kk = u.k,level = u.used; if(v[u.k][u.used]) continue; v[u.k][u.used] = 1; for(register int i = d[kk]; i; i = edge[i].next) { int too = edge[i].to; if(D[too][level] &gt; D[kk][level] + edge[i].x) { D[too][level] = edge[i].x + D[kk][level]; que.push((node){too,D[too][level],level}); } if(level &lt; k &amp;&amp; D[too][level + 1] &gt; D[kk][level]) { D[too][level + 1] = D[kk][level]; que.push((node){too,D[too][level + 1],level + 1}); } } } long long ans = INF; for(register int i = 0; i &lt;= k; i++) ans = min(ans,D[t][i]); printf("%lld\n",ans); return 0;} 推荐练习题目：飞行路线、冻结、回家的路]]></content>
  </entry>
  <entry>
    <title><![CDATA[小Z的袜子-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%B0%8FZ%E7%9A%84%E8%A2%9C%E5%AD%90-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 突然感觉qxy和小z是同种生物莫队的一道裸题虽说莫队算是一种暴力的算法，但ta依然是某些题目的正解的。（dfs：我不服） 这道题是需要我们经过一定的数学推导才可以做出来的。具体过程如下：对于L,R的询问。 设其中颜色为x,y,z的袜子的个数为a,b,c… 那么答案即为 (a*(a-1)/2+b*(b-1)/2+c*(c-1)/2....)/((R-L+1)*(R-L)/2) 化简得: (a^2+b^2+c^2+...x^2-(a+b+c+d+.....))/((R-L+1)*(R-L)) 即： (a^2+b^2+c^2+...x^2-(R-L+1))/((R-L+1)*(R-L)) 于是这道题目变成了求a^2+b^2+c^2+...x^2，这个过程我们可以用莫队去实现。 附一下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define re register#define INF 0x7fffffffusing namespace std;long long read(){ long long x = 0,f = 1; char ch; ch = getchar(); while(ch &gt;'9' || ch &lt; '0'){if(ch == '-') f = -f; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9'){x = x * 10 + ch - '0'; ch = getchar();} return x * f;}long long gcd(long long a, long long b){return a == 0 ? b : gcd(b % a, a);}long long n,m,a[50005],xsort,p1,p2,t[50005],ans,cnt,g,ll,rr,in[50005],save1[50005],save2[50005];struct query{ long long l,r,num;}q[50005];long long mysort(query x, query y){ if(x.l / xsort == y.l / xsort) return x.r &lt; y.r; return x.l &lt; y.l;}long long work(long long x){ return x * x;}void add(long long k){ long long u = a[k]; if(k == 0) return ; ans = ans - work(t[u]); t[u] ++; ans = ans + work(t[u]);}void del(long long k){ long long u = a[k]; if(k == 0) return ; ans = ans - work(t[u]); t[u] --; ans = ans + work(t[u]);}int main(){ n = read(); m = read(); for(re int i = 1; i &lt;= n; i ++) a[i] = read(); for(re int i = 1; i &lt;= m; i++) { q[i].l = read(); q[i].r = read(); q[i].num = i; } xsort = sqrt(n); sort(q + 1, q + m + 1, mysort); for(re int i = 1; i &lt;= m; i++) { ll =q[i].l; rr = q[i].r; while(p1 &lt; ll){del(p1); p1 ++;} while(p1 &gt; ll){p1 --; add(p1);} while(p2 &lt; rr){p2 ++; add(p2);} while(p2 &gt; rr){del(p2); p2 --;} cnt = (rr - ll + 1) * (rr - ll); save1[q[i].num] = ans - (rr - ll + 1); save2[q[i].num] = cnt; } for(re int i = 1; i &lt;= m; i++) { if(save1[i] != 0 &amp;&amp; save2[i] != 0) g = gcd(save1[i],save2[i]); else g = 1; if(save1[i] == 0 || save2[i] == 0) {printf("0/1\n"); continue ;} printf("%d/%d\n",save1[i] / g,save2[i] / g); } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序-学习]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[·拓扑排序是什么呢？我们先来看一下标准解释：对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。 额，是不是有点懵……其实，通俗易懂地说，拓扑排序就是在一个DAG中，对所有的节点进行排序，要求在序列中没有一个节点有边指向序列中它前面的节点。 ·那么，我们该怎么去实现呢？其实，求拓扑排序的过程，就是一个不断寻找入度为零的点和删边的过程。 如果一个点的入度为零，那么它一定可以直接被选（因为任何目前没有被选择的点都不可能在有边连向这一个点了）。每当我们选择一个点放入序列后，我们就要把所有以这个节点为起点的边都删掉，并更新其它点的入度。 tip：对于同一个图，拓扑排序后可能存在多种合法答案。 附一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;queue&gt; using namespace std; queue&lt;int&gt;que; //拓扑排序的过程也不一定用队列去实现 int t,n,m,x,y,cnt,d[100005],k[100005],ans[100005]; struct Edge{ int to,next; }edge[100005]; void add(int x,int y) { edge[++cnt].to = y; edge[cnt].next = d[x]; d[x] = cnt; k[y] ++; } void work() { for(register int i = 1; i &lt;= n; i++) if(k[i] == 0) que.push(i); //将所有入度为0的点入队 //cout &lt;&lt; que.top()&lt;&lt;endl; while(!que.empty()) { x = que.front(); //取队首元素 ans[++cnt] = x; //ans记录答案 que.pop(); for(register int i = d[x]; edge[i].to != 0; i = edge[i].next) { k[edge[i].to] --; //更新其它节点的入度 if(k[edge[i].to] == 0) //若入度为0，则将这个节点入队 que.push(edge[i].to); } } } int main() { cin &gt;&gt; n &gt;&gt; m; //表示有n个点，m条边 for(int i = 1; i &lt;= m ;i++) //存边 { cin &gt;&gt; x&gt;&gt;y; add(x,y); } cnt = 0; work(); //拓扑排序 for(register int i = 1; i &lt;= n; i++) printf("%d ",ans[i]); return 0; }]]></content>
  </entry>
  <entry>
    <title><![CDATA[无线通讯网-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%97%A0%E7%BA%BF%E9%80%9A%E8%AE%AF%E7%BD%91-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[直到敲完这个题，我才发现原来prim如果用邻接矩阵存图即使加上堆优化时间复杂度依然是O(n2)qwq…… 首先，由于两个点只需要间接联通就可以互相通讯，所以这道题可以用最小生成树去做。这一步比较好完成。 问题在于怎么去加卫星电话。由于两个点只要间接联通就可以，那么每一个用无线电收发器连成的子图只需要有一个卫星电话即可与其它的点联通，所以我们在删边的时候需要先判断一下这两个点删完边以后是不是仍然联通而不是傻傻地给这两个点都安装上卫星电话（被这个卡了好久qwq） 如图所示，由于2、4号点都安装了电话，所以删掉边1-3后，1、3号点之间就不需要安装电话的。 再来看如何安装电话。如图，我们可以发现，当前两个点安装完卫星电话以后，每一个子图都会拥有一个卫星电话。当我们继续删边时，分成的两个新的子图都是一个有卫星电话，一个没有，所以我们从第二次开始每次删边只需要增加一部卫星电话即可。所以最终留下的最大的边是第s大的边（由于第一次删边你需要安装两台卫星电话，所以你最多只能删s - 1条边）附一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}struct NODE{ int x, y, num; double minn;}a[1000];int s,p,vis[1000],del[1000],fa[1000],f[1000];struct node{ int k; double dis; bool operator &lt; ( const node &amp;x )const{return x.dis &lt; dis;}};priority_queue &lt;node&gt; que;int mysort(NODE a, NODE b){return a.minn &gt; b.minn;}int main(){ s = read(); p = read(); for(re int i = 1; i &lt;= p; i++) { a[i].x = read(); a[i].y = read(); a[i].num = i; } for(re int i = 1; i &lt;= p; i++) a[i].minn = INF; que.push((node){1,0}); vis[1] = 1;a[1].minn = 0; while(!que.empty()) { node now = que.top(); que.pop(); vis[now.k] = 1; for(re int i = 1; i &lt;= p; i++) { if(!vis[i] &amp;&amp; sqrt((a[now.k].x - a[i].x) * (a[now.k].x - a[i].x) + ((a[now.k].y - a[i].y) * (a[now.k].y - a[i].y))) &lt; a[i].minn) { a[i].minn = sqrt((a[now.k].x - a[i].x) * (a[now.k].x - a[i].x) + ((a[now.k].y - a[i].y) * (a[now.k].y - a[i].y))); que.push((node){i,a[i].minn}); fa[i] = now.k; } } } sort(a + 1, a + p + 1, mysort); int j = 1; double Min = a[j].minn; Min = a[s].minn; printf("%.2lf\n",Min); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[最短路计数-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%AE%A1%E6%95%B0-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 虽然题目叫最短路计数，但是TA可以只用到最短路的概念而不用最短路的算法……由于这是一个无权图，所以一条路径上边的数量就是这条路径的长度，那么我们就可以用BFS来搞定这个问题了。 具体思路我们每遍历到一个节点就和ta的前一个结点的距离比较，这里会有三种情况：(由1到2) 2号点没有被访问过||time[1] + 1 &lt; time[2]：此时我们直接用1号点的信息去更新2就好啦 time[1] + 1 = time[2] : 这个我们就只需要更新一下ans就可以啦 time[1] + 1 &gt; time[2] :此时这条路径比之前的某条路径要长，直接跳过就可以啦代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}queue&lt;int&gt; que;struct edge{ int next,to,v;}e[2000005];int n,m,cnt,x,now,y,tim[2000000],ans[2000000],d[2000000];inline int add(int x,int y){ e[++cnt].to = y; e[cnt].next = d[x]; d[x] = cnt;}int main(){ n = read(); m = read(); for(re int i = 1; i &lt;= m; i++) { x = read(); y = read(); add(x,y); add(y,x); } que.push(1); ans[1] = 1; while(!que.empty()) { now = que.front(); que.pop(); for(re int i = d[now]; i; i = e[i].next) { if(tim[now] + 1 &lt; tim[e[i].to] || tim[e[i].to] == 0) { tim[e[i].to] = tim[now] + 1; ans[e[i].to] = ans[now]; que.push(e[i].to); } else if(tim[now] + 1 == tim[e[i].to]) ans[e[i].to] = (ans[e[i].to] + ans[now]) % 100003; } } ans[1] = 1; for(re int i = 1; i &lt;= n; i++) printf("%d\n",ans[i]); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[欧拉回路-学习]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[定义欧拉路径（欧拉通路）：通过图中所有边的简单路。（换句话说，每条边都通过且仅通过一次）也叫”一笔画”问题。欧拉回路：闭合的欧拉路径。（即一个环，保证每条边都通过且仅通过一次）欧拉图：包含欧拉回路的图。 起源在一个图中求解一条欧拉回路的问题，起源于欧拉提出的、著名的“七桥问题”。详见百度百科。 判定欧拉路径： 1.图G是连通的，无孤立点。2.无向图奇点数为0或2，并且这两个奇点其中一个为起点另外一个为终点。有向图，可以存在两个点，其入度不等于出度，其中一个入度比出度大1，为路径的起点；另外一个出度比入度大1，为路径的终点。 欧拉回路 1.图G是连通的，无孤立点。2.无向图奇点数为0；有向图每个点的入度必须等于出度。 算法求欧拉回路的算法中，普遍使用的是Fleury算法和Hierholzer算法。由于Hierholzer算法在时间复杂度和代码实现上都更优，所以这里只介绍一下Hierholzer算法。主要是我不会敲Fleury…… Hierholzer算法思路 1.根据每个点的入度选择起点。2.运用DFS去遍历当前节点的每一条边，之后将该节点压入栈中。3.操作2接受后，栈中的元素就是一条欧拉回路。 附一下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define INF 0x7fffffff#define ll long longusing namespace std;int n,m,x,y,head[1200],cnt,map[1030][1030],d[1030],begin,s[1030],t;void dfs(int k){ for(register int i = 1; i &lt;= n; i++) { if(map[k][i] &gt; 0) { map[k][i] --; map[i][k] --; dfs(i); } } s[++t] = k;}int main(){ scanf("%d",&amp;m); for(register int i = 1; i &lt;= m; i++) { scanf("%d%d",&amp;x,&amp;y); map[x][y] ++; map[y][x] ++; n = max(n,x); n = max(n,y); d[x] ++; d[y] ++; } for(register int i = 1; i &lt;= n; i++) { if(d[i] % 2 == 1) { begin = i; break; } } if(begin == 0) begin = 1; dfs(begin); for(register int i = t; i &gt;0; i--) printf("%d\n",s[i]); printf("\n"); return 0;} 推荐联系题目：骑马修栅栏、无序字母对]]></content>
  </entry>
  <entry>
    <title><![CDATA[求和-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%B1%82%E5%92%8C-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 前言 没有什么是吸一口氧气解决不了的，如果有，就再吸一口…… 算法朴素暴力 首先，看到这道题的第一时间就想到了一个暴力的方法——枚举每一个x点和x与z的间距（只需要枚举偶数间接即可，否则无法满足y−x=z−y）。然而，这个算法是$O(n^2)$的，我们无法承受这个时间复杂度。 优化暴力思路 其实感觉还是挺慢的，需要吸一口氧气才能过 由于朴素的暴力需要枚举每一个起点和间接，但是如果我们对数据排一下序呢？ 是的，这样我们就可以不必枚举每一个间距了。但是呢，由于这个方法本质还是一个暴力，我们在统计答案的时候速度会比较慢qwq 排序 那么，我们怎么去进行排序呢？ 我们可以发现，y的值对于答案是没有任何影响的，只要x和z的编号同为奇数或偶数，那么就一定存在一个y使得y−x=z−y。所以，我们在排序时的关键字的优先级应该时这样的： 1. 颜色 2. 序号的奇偶（可以偶数在前，也可以奇数在前，但必须保证统一颜色的奇数和偶数编号的点是挨着的） 3. 序号的大小（感觉这个其实没什么用qwq） 然后我们只需要枚举每一个颜色和奇偶均相同的区间并统计答案即可代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re register#define mod 10007using namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}struct number{ ll num,col,x;}a[100005];ll n,m,s,ans;int mysort(number a, number b){ if(a.col != b.col) return a.col &lt; b.col; if(a.num % 2 == b.num % 2) return a.num &lt; b.num; return a.num % 2 &lt; b.num % 2;}int main(){ n = read(); m = read(); for(re int i = 1; i &lt;= n; i++) a[i].num = i; for(re int i = 1; i &lt;= n; i++) a[i].x = read(); for(re int i = 1; i &lt;= n; i++) a[i].col = read(); sort(a + 1, a + n + 1, mysort); int i = 1; while(i &lt;= n){ s = i; while(a[i].col == a[i + 1].col &amp;&amp; a[i].num % 2 == a[i + 1].num % 2 &amp;&amp; i &lt; n) i ++; for(int j = s; j &lt; i; j++) for(int k = j + 1; k &lt;= i; k++) ans = (ans + (a[j].num + a[k].num) * (a[j].x + a[k].x)) % mod; i++; } printf("%lld\n",ans); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[滑雪-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%BB%91%E9%9B%AA-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 解题思路首先，因为题目要求求“即满足经过景点数最大的前提下使得滑行总距离最小”，所以这道题目我们可以用最小生成树来解决。 具体做法核心算法 这里推荐用kruskal去求最小生成树(prim虽然加上堆优化也应该不会超时，但是ta真的是代码难敲效率还低qwq)。 因为这道题目对于每个点的高度都有一个限制，所以有些点即使是有边相连也是到不了的。此时我们可以先统计可以到达的边，然后只储存两个端点都可以到达的边。 注意事项 因为每个点具有高度，所以建边是应根据情况选择建单向边还是双向边。 由于每个点的高度都有限制，所以并不是某个点在一开始统计的时候统计为能到达就可以随意选边。 如图，如果我们直接按照边权从小到大排序，那么我们会选择（2）号边。但实际上，3号点是到不了4号点的，所以我们应优先选择终点高度高的（1）号边。 因此我们在对边进行排序是，应把终点的高度设为第一关键字，把边权设为第二关键字 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}struct edge1{ int next,to,k,from;}edge[2000005];struct edge2{ int x,y,k;}e[2000005];long long n,m,u,v,k,t,cnt,ans,tot,h[100005],d[100005],vis[100005],fa[100005];void add(int x, int y, int k){ edge[++cnt].to = y; edge[cnt].k = k; edge[cnt].next = d[x]; edge[cnt].from = x; d[x] = cnt;}void dfs(int s){ vis[s] = 1; for(re int i = d[s]; i; i = edge[i].next) if(!vis[edge[i].to]) dfs(edge[i].to);}int mysort(edge2 a, edge2 b){ if(h[a.y] != h[b.y]) return h[a.y] &gt; h[b.y]; return a.k &lt; b.k;}int find(int x) {if(fa[x] == x) return x; return fa[x] = find(fa[x]);}void kruskal(){ for(re int i = 1; i &lt;= n; i++) fa[i] = i; sort(e + 1, e + t + 1, mysort); for(re int i = 1; i &lt;= t; i++) { if(find(e[i].x) != find(e[i].y)) { ans = ans + e[i].k; fa[find(e[i].x)] = find(e[i].y); } }}int main(){ n = read(); m = read(); for(re int i = 1; i &lt;= n; i++) h[i] = read(); for(re int i = 1; i &lt;= m; i++) { u = read(); v = read(); k = read(); if(h[u] &gt;= h[v]) add(u,v,k); if(h[u] &lt;= h[v]) add(v,u,k); } dfs(1); for(re int i = 1; i &lt;= cnt; i ++) { if((edge[i].from != edge[i - 1].to || edge[i].to != edge[i - 1].from) &amp;&amp; vis[edge[i].from] &amp;&amp; vis[edge[i].to]) { e[++t].k = edge[i].k; e[t].x = edge[i].from; e[t].y = edge[i].to; } } kruskal(); for(re int i = 1; i &lt;= n; i++) if(vis[i]) tot ++; printf("%lld %lld\n", tot, ans); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[IncDec Sequence - 题解]]></title>
    <url>%2F2019%2F08%2F02%2FIncDec%20Sequence%20-%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 一道练习差分的好题第一眼看到这个题，一个清晰的暴力思路就浮现与脑海之中…… 好吧，暴力是肯定要超时的，但是差分就不会了。因为修改一个长度为m的区间，暴力的复杂度是O(m),但差分的复杂度是O(1)的。 为什么会想到去用差分呢因为这道题我们是需要把所有数之间的差都变为0，而差分的实现正好于此类似。 那么，具体该怎么做呢？很简单，如果两个数的差为2，那么我们只需要操作两次即可让这两个数的值相同。所以，我们可以统计出差分数组中的正数的和与负数的和，取其中的最大值就是最少的操作次数了。具体为什么不用管少的那一个，是因为在处理多的那一个的同时少的那一个同样会被处理，且绝对值小的是会被先处理完的。 附一下代码： #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; using namespace std; int a[100005],s[100005]; int main(){ int n,up,down; scanf(“%d”,&amp;n); for(register int i = 1; i &lt;= n; i++) scanf(“%d”,&amp;a[i]); s[1] = a[1]; for(register int i = 2; i &lt;= n; i++) { s[i] = a[i] - a[i - 1]; if(s[i] &gt; 0) up += s[i]; else down -= s[i]; } printf(“%d\n%d\n”,max(up,down),abs(up - down + 1)); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[银河英雄传说-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E9%93%B6%E6%B2%B3%E8%8B%B1%E9%9B%84%E4%BC%A0%E8%AF%B4-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 算法思路题目中一共给了合并和查询和两种操作，很显然我们可以用并查集来实现。但是，查询操作需要给出两个点之间的距离，那么我们怎么去统计这个量呢？如图，我们可以发现，如果我们想要知道4号点到2号点的距离，如果不压缩路径，我们可以选择一步步去统计这两个点到祖先的距离，然后进行计算。但是，1e5的数据显然是不支持这个时间复杂度的。那么，我们该怎么做呢？答案就是用加权并查集。 加权并查集和朴素并查集的区别是并查集在统计某节点的父亲节点的同时，还统计该节点到ta的祖先节点的距离。这样，我们就可以进行路径压缩而不是只能一步一步往上跳。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}const int n = 30000;int fa[100005],dis[100005],siz[100005],t,x,y;char s;int query(int x){ if(fa[fa[x]] == fa[x]) return dis[x]; return dis[x] + dis[query(fa[x])];}int find(int x){ if(fa[x] == x) return x;// dis[x] = query(x); int ans = find(fa[x]); dis[x] = dis[fa[x]] + dis[x]; fa[x] = ans; return ans;}int main(){ t = read(); for(int i = 1; i &lt;= n; i ++) fa[i] = i; for(int i = 1; i &lt;= n; i ++) siz[i] = 1; for(int i = 1; i &lt;= t; i ++) { cin &gt;&gt; s; x = read(); y = read(); if(s == 'M') { int fx = find(x),fy = find(y); if(find(x) != find(y)) { dis[fx] = dis[fx] + siz[fy]; siz[fy] += siz[fx]; siz[fx] = 0; fa[fx] = fy; } } if(s == 'C') { if(find(x) != find(y)) { printf("-1\n"); continue; } if(x == y) { printf("0\n"); continue; } printf("%d\n",abs(dis[x] - dis[y]) - 1); } } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[食物链-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E9%A3%9F%E7%89%A9%E9%93%BE-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 和关押罪犯差不多，也是一个种类并查集的题目。不过关押罪犯有两个种类，而这个题复杂一些，有三个种类，但大体思路都是一样的，我们只需要开三倍空间就可以了。对于每一句话，我们只需要判断它和前面的记录是否冲突，若冲突，则让ans + 1，否则按照这句话的要求去修改。 Tips： 因为要开三倍空间，所以我们在初始化的时候也要对这三倍的空间都进行初始化。 在每次更新的时候，我们都要将这三倍的空间分别更新。 附一下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;int n,m,s,x,y,ans,f[150005];int find(int x){ if(f[x] == x) return x; return f[x] = find(f[x]);}int main(){ scanf("%d%d",&amp;n,&amp;m); for(register int i = 1; i &lt;= n; i++) { f[i] = i; f[i + n] = i + n; f[i + n + n] = i + n + n; } for(register int i = 1; i &lt;= m; i++) { scanf("%d%d%d",&amp;s,&amp;x,&amp;y); if(x &gt; n || y &gt; n) { ans ++; continue ; } if(s == 1) { if(find(x) == find(y + n) || find(y) == find(x + n)) { ans ++; continue ; } f[find(x)] = f[find(y)]; f[find(x + n)] = f[find(y + n)]; f[find(x + n + n)] = f[find(y + n + n)]; } if(s == 2) { if(find(x) == find(y) || find(x + n) == find(y)) { ans ++; continue ; } f[find(x)] = f[find(y + n)]; f[find(x + n)] = f[find(y + n + n)]; f[find(x + n + n)] = f[find(y)]; } } printf("%d\n",ans); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[splay-学习]]></title>
    <url>%2F2019%2F08%2F02%2Fsplay-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[其实……说实话我还真的不是非常会用qwq先存一下板子把，以后慢慢来qwq 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define re register#define INF 0x7fffffff#define ll long longusing namespace std;int read(){ int x = 0,f = 1; char ch; ch = getchar(); while(ch &gt;'9' || ch &lt; '0'){if(ch == '-') f = -f; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9'){x = x * 10 + ch - '0'; ch = getchar();} return x * f;}struct node{ int fa,son[2],v,tie,siz;}e[1000000];int root,tot;void rotate(int x){ int y = e[x].fa, z = e[y].fa, mode = 0; if(e[z].son[0] == y) e[z].son[0] = x; else e[z].son[1] = x; e[x].fa = z; if(e[y].son[0] == x) mode ++; e[y].son[mode ^ 1] = e[x].son[mode]; e[e[x].son[mode]].fa = y; e[x].son[mode] = y; e[y].fa = x; e[y].siz = e[e[y].son[0]].siz + e[e[y].son[1]].siz + e[y].tie; e[x].siz = e[e[x].son[0]].siz + e[e[x].son[1]].siz + e[x].tie;}void splay(int x){ while(e[x].fa) { int y = e[x].fa, z = e[y].fa; if(z) { if((e[y].son[0] == y) ^ (e[y].son[0] == x)) rotate(x); else rotate(y); } rotate(x); } root = x;}int find(int now, int w){ while(e[now].v != w) { if(w &lt; e[now].v) { if(e[now].son[0]) now = e[now].son[0]; else break; } else { if(e[now].son[1]) now = e[now].son[1]; else break; } } return now;}void add(int f, int w){ e[++ tot].fa = f; e[tot].tie = 1; e[tot].siz = 1; e[tot].v = w;}void ins(int p){ if(!tot) { add(0,p); root = 1; return ; } int pos = find(root,p); if(e[pos].v == p) e[pos].tie ++; else { add(pos,p); if(p &lt; e[pos].v) e[pos].son[0] = tot; else e[pos].son[1] = tot; } for(int now = pos; now; ++e[now].siz,now = e[now].fa); if(e[pos].v == p) splay(pos); else splay(tot);}void del(int p){ int pos = find(root,p); if(e[pos].v != p) return ; splay(pos); if(e[pos].tie &gt; 1) { e[pos].tie --; e[pos].siz --; return ; } if(!e[pos].son[0]) { e[e[pos].son[1]].fa = 0; root = e[pos].son[1]; if(!root) tot = 0; } else { e[e[pos].son[0]].fa = 0; int lax = find(e[pos].son[0],1000000); splay(lax); e[root].siz += e[e[pos].son[1]].siz; e[root].son[1] = e[pos].son[1]; e[e[pos].son[1]].fa = root; } e[pos].v = 0; e[pos].tie = 0; e[pos].siz = 0; e[pos].fa = 0; e[pos].son[0] = 0; e[pos].son[1] = 0;}int rank(int p){ int pos = find(root,p); splay(pos); return e[e[pos].son[0]].siz + 1;}int k_th(int p){ int now = root; for(int bot = e[e[now].son[0]].siz; p &lt;= bot || p &gt; bot + e[now].tie; bot = e[e[now].son[0]].siz) if(p &gt; bot + e[now].tie) { p = p - bot - e[now].tie; now = e[now].son[1]; } else now = e[now].son[0]; return e[now].v;}int pred(int p){ int pos = find(root,p); if(e[pos].v &lt; p) return e[pos].v; splay(pos); return e[find(e[pos].son[0],10000000)].v;}int succ(int p){ int pos = find(root,p); if(e[pos].v &gt; p) return e[pos].v; splay(pos); return e[find(e[pos].son[1],0)].v;}int main(){// freopen("a.txt","w",stdout); int m,mode,x; scanf("%d",&amp;m); while (m--) { scanf("%d%d",&amp;mode,&amp;x); switch (mode) { case 1:ins(x);break; case 2:del(x);break; case 3:printf("%d\n",rank(x));break; case 4:printf("%d\n",k_th(x));break; case 5:printf("%d\n",pred(x));break; case 6:printf("%d\n",succ(x));break; } } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[树-学习]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%A0%91-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[树的直径定义 给定一棵树，树中每条边都有一个权值，树中两点之间的距离定义为连接两点的路径边权之和。树中最远的两个节点之间的距离被称为树的直径，连接这两点的路径被称为树的最长链。后者通常也可称为直径，即直径是一个数值概念，也可代指一条路径 性质 直径两端点一定是两个叶子节点 距离任意点最远的点一定是直径的一个端点，这个基于贪心求直径方法的正确性可以得出 对于两棵树，如果第一棵树直径两端点为(u,v)，第二棵树直径两端点为(x,y)，用条边将两棵树连接，那么新树的直径一定是u,v,x,y中的两个点 对于一棵树，如果在一个点的上接一个叶子节点，那么最多会改变直径的一个端点 若一棵树存在多条直径，那么这些直径交于一点且交点是这些直径的中点算法求树的直径有两种算法,一种是跑两边搜索,另一种是用树形DP去求(可惜我不会qwq)这里我们来介绍用两遍搜索求树的直径的方法.首先,我们从任意一个点出发,找出和ta的距离最远的点u;然后再从u出发,搜索树上距离u最远的节点v.u和v之间的路径就是树的直径.证明:OI不需要证明……代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}struct edge{ int next,to,v;}e[100005];int n,m,x,y,z,cnt,maxx,j,d[100005],vis[100005],last[100005];void add(int x, int y, int z){ e[++cnt].to = y; e[cnt].v = z; e[cnt].next = d[x]; d[x] = cnt;}void dfs(int k, int l){ if(l &gt; maxx) { maxx = l; j = k; } for(re int i = d[k]; i; i = e[i].next) if(!vis[e[i].to]) { vis[e[i].to] = 1; last[e[i].to] = k; dfs(e[i].to,l + e[i].v); }}void work(){ vis[1] = 1; dfs(1,0); memset(vis,0,sizeof(vis)); memset(last,0,sizeof(last)); maxx = 0; vis[j] = 1; dfs(j,0); printf("%d\n",maxx); while(j != 0) { printf("%d ",j); j = last[j]; }}int main(){ n = read(); m = read(); for(re int i = 1; i &lt;= m; i++) { x = read(); y = read(); z = read(); add(x,y,z); add(y,x,z); } work(); return 0;} 树的重心定义 树的重心也叫树的质心。对于一棵树n个节点的无根树，找到一个点，使得把树变成以该点为根的有根树时，最大子树的结点数最小。换句话说，删除这个 点后最大连通块（一定是树）的结点数最小。 性质 树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个距离和，他们的距离和一样。 把两棵树通过一条边相连，新的树的重心在原来两棵树重心的连线上。 一棵树添加或者删除一个节点，树的重心最多只移动一条边的位置。 一棵树最多有两个重心，且相邻。算法和树的最大独立问题类似，先任选一个结点作为根节点，把无根树变成有根树，然后设d(i)表示以i为根的子树的结点的个数。不难发现d(i)=∑d(j)+1，j∈s（i）。s（i）为i结点的所有儿子结点的编号的集合。程序也十分简单：只需要DFS一次，在无根树有根数的同时计算即可，连记忆化都不需要——因为本来就没有重复计算。代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}struct edge{ int next,to,v;}e[100005];int n,m,x,y,z,cnt,maxx,j,d[100005],vis[100005],last[100005];void add(int x, int y, int z){ e[++cnt].to = y; e[cnt].v = z; e[cnt].next = d[x]; d[x] = cnt;}void dfs(int k, int l){ if(l &gt; maxx) { maxx = l; j = k; } for(re int i = d[k]; i; i = e[i].next) if(!vis[e[i].to]) { vis[e[i].to] = 1; last[e[i].to] = k; dfs(e[i].to,l + e[i].v); }}void work(){ vis[1] = 1; dfs(1,0); memset(vis,0,sizeof(vis)); memset(last,0,sizeof(last)); maxx = 0; vis[j] = 1; dfs(j,0); printf("%d\n",maxx); while(j != 0) { printf("%d ",j); j = last[j]; }}int main(){ n = read(); m = read(); for(re int i = 1; i &lt;= m; i++) { x = read(); y = read(); z = read(); add(x,y,z); add(y,x,z); } work(); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口-题解]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看原题请戳这里 暴力做法枚举呗……时间复杂度$O(n^2)$。显然，这种复杂度不是我们可以接受的 线段树做法ps： 感觉这东西还是暴力……由于这道题目问的是区间的最大值和最小值，所以我们可以用线段树去解决。（只有查询，可好敲了）但是呢，由于线段树的复杂度是$O(nlogn)$的，而且ta常数比较大，所以会超时qwq附一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;malloc.h&gt; #define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}struct tree{ int maxx,minn; tree *lson,*rson;}*root = (tree*)malloc(sizeof(tree));struct node{ int a,b;}ans[1000005];void build(tree *tre,int l,int r){ if(l == r) { tre -&gt; maxx = read(); tre -&gt; minn = tre -&gt; maxx; return; } int mid = (l + r) &gt;&gt; 1; tree *son1 = (tree*)malloc(sizeof(tree)); tree *son2 = (tree*)malloc(sizeof(tree)); tre -&gt; lson = son1; tre -&gt; rson = son2; build(tre -&gt; lson,l,mid); build(tre -&gt; rson,mid + 1,r); tre -&gt; maxx = max(tre -&gt; lson -&gt; maxx,tre -&gt; rson -&gt; maxx); tre -&gt; minn = min(tre -&gt; lson -&gt; minn,tre -&gt; rson -&gt; minn);}node query(tree *tre,int l,int r,int x,int y){ if(l == r) return (node){tre -&gt; maxx,tre -&gt; minn}; int mid = (l + r) &gt;&gt; 1; node t1,t2; t1.a = -INF; t1.b = INF; t2.a = -INF; t2.b = INF; if(x &lt;= mid) t1 = query(tre -&gt; lson,l,mid,x,y); if(y &gt; mid) t2 = query(tre -&gt; rson,mid + 1,r,x,y); return (node){max(t1.a,t2.a),min(t1.b,t2.b)};}int main(){ int n,k; n = read(); k = read(); build(root,1,n); for(int i = 1; i &lt;= n - k + 1; i++) ans[i] = query(root,1,n,i,i + k - 1); for(int i = 1; i &lt;= n - k + 1; i++) printf("%d ",ans[i].b); printf("\n"); for(int i = 1; i &lt;= n - k + 1; i++) printf("%d ",ans[i].a); printf("\n"); return 0;} 单调队列做法终于到正解了……直接用单调队列瞎搞一下就可以啦，时间复杂度是$O(n)$的对于每次入队，我们都要判断一下，如果该数大于队尾，则直接入队，否则将队列中所有比ta小的数字全部出队，然后再入队，这样就能保证队列的单调性。对于每次出队，我们都要判断一下要出队的元素是否还在队列中（可能在别的元素入队的时候出队了）附一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}int n,k,a[1000005],que[1000006],head=1,tail;void q_push1(int k){ if(head &gt; tail) { que[++tail] = k; return ; } if(k &lt;= que[tail]) { que[++tail] = k; return ; } while(que[tail] &lt; k &amp;&amp; tail &gt;= head) tail--; que[++tail] = k;}void q_push2(int k){ if(head &gt; tail) { que[++tail] = k; return ; } if(k &gt;= que[tail]) { que[++tail] = k; return ; } while(que[tail] &gt; k &amp;&amp; tail &gt;= head) tail--; que[++tail] = k;}int main(){ n = read(); k = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(); for(int i = 1; i &lt;= n; i++) { if(i - k &gt; 0) if(a[i - k] == que[head]) head ++; q_push2(a[i]); if(i &gt;= k)printf("%d ",que[head]); } printf("\n"); head = 1; tail = 0; for(int i = 1; i &lt;= n; i++) { if(i - k &gt; 0) if(a[i - k] == que[head]) head ++; q_push1(a[i]); if(i &gt;= k)printf("%d ",que[head]); } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[最小生成树-学习]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[隔了几个月，又开始写博客了qwq kruskal时间复杂度为O(nlogn)它的算法思路是这样的：我们根据边的权值将所有边排序，然后枚举每条边，用并查集去查询这条边的两个端点是否在同一集合内，若在同一集合内，则删掉这条边，若不在同一结合则加入这条边，并将这两个端点所在的集合合并。附一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,m,q[6000];struct lalala{ int x,y,z,save;}a[210000];int mysort(lalala a,lalala b){ return a.z &lt; b.z;}int work(int x,int y){ while(q[q[x]] != q[x]) q[x] = q[q[x]]; while(q[q[y]] != q[y]) q[y] = q[q[y]]; if(q[x] == q[y]) return 1; else { q[q[y]] = q[x]; return 0; }}int main(){ long long ans = 0; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) q[i]=i; for(int i=1; i&lt;=m; i++) { cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].z; ans += a[i].z; } sort(a+1,a+m+1,mysort); for(int i=1;i&lt;=m;i++) { if(!work(a[i].x,a[i].y)) ans -= a[i].z; } cout &lt;&lt; ans; return 0;} prim时间复杂度O(n2)跑得慢，代码长，没特殊功能，真不知道为什么要学它qwq……prim的思想和某最短路算法的思路是类似的，我们将更新过的点标为白色，没有更新过的标为蓝色，然后枚举每一个蓝点（按minn值从小到大更新，这里貌似可以用堆优化，然而我比较懒qwq）并更新为白点，并用它去更新其他的蓝点（这里不用把被更新的点标为白色，不然它们就没法更新其他点，也没法被其他的点更新了）。最后将每个点的minn值加起来就好啦。附一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll long long#define INF 2147483647using namespace std;struct node{ int k,dis; bool operator &lt; ( const node &amp;x )const{return x.dis &lt; dis;}};priority_queue&lt;node&gt; que;long long n,m,s,d[1000005],cnt,D[1000005],v[1000005]; struct Edge{ int to,next,x;}edge[2000005];void add(int x,int y,int a){ edge[++cnt].to = y; edge[cnt].x = a; edge[cnt].next = d[x]; d[x] = cnt;}int main(){ int x,y,a; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;s); for(register int i = 1; i &lt;= m; i++) { scanf("%d%d%d",&amp;x,&amp;y,&amp;a); add(x,y,a); } que.push((node){s,0}); for(register int i = 1; i &lt;= n; i++) D[i] = INF; D[s] = 0; while(!que.empty()) { node u = que.top(); que.pop(); if(v[u.k]) continue; v[u.k] = 1; for(register int i = d[u.k]; i; i = edge[i].next) { if(D[edge[i].to] &gt; D[u.k] + edge[i].x) { D[edge[i].to] = edge[i].x + D[u.k]; if(!v[edge[i].to]) que.push((node){edge[i].to,D[edge[i].to]}); } } } for(register int i = 1; i &lt;= n; i++) printf("%d ",D[i]); printf("\n"); return 0;} prim的堆优化既然prim和某最短路算法的思路是相似的，那么ta和某最短路算法一样也可以用堆优化，可以把时间复杂度从O(n2)降到O(nlongn)依然是跑得慢，代码长，没特殊功能qwq……附一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read(){ register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0'){if(ch == '-') f = -f;ch = getchar();} while(ch &lt;= '9' &amp;&amp; ch &gt;= '0'){x = x * 10 + ch - 48;ch = getchar();} return x * f;}struct edge{ int x,y,z;}a[500005];struct EDGE{ int next,to,x,save;}e[500005];struct node{ int k,dis; bool operator &lt; (const node &amp; x) const {return x.dis &lt; dis;}}now;priority_queue &lt;node&gt; que;int cnt,d[100005];void add(int x,int y,int a){ e[++cnt].to = y; e[cnt].x = a; e[cnt].next = d[x]; d[x] = cnt;}int n,m,q,x,y,z,ans,minn[100005],vis[100005];int mysort(edge a1, edge a2){ if(a1.x != a2.x) return a1.x &lt; a2.x; if(a1.y != a2.y) return a1.y &lt; a2.y; return a1.z &lt; a2.z;}int main(){ n = read(); m = read(); for(re int i = 1; i &lt;= m; i++) { a[i].x = read(); a[i].y = read(); a[i].z = read(); } sort(a + 1, a + m + 1, mysort); for(re int i = 1; i &lt;= m; i++) if(a[i].x != a[i - 1].x || a[i].y != a[i - 1].y) { add(a[i].x, a[i].y, a[i].z); add(a[i].y, a[i].x, a[i].z); } for(re int i = 1; i &lt;= n; i++) minn[i] = INF; que.push((node){1,0}); while(!que.empty()) { now = que.top(); que.pop(); vis[now.k] = 1; for(re int i = d[now.k]; i; i = e[i].next) if(!vis[e[i].to] &amp;&amp; e[i].x &lt; minn[e[i].to]) { minn[e[i].to] = e[i].x; que.push((node){e[i].to,minn[e[i].to]}); } } for(re int i = 2; i &lt;= n; i++) ans = ans + minn[i]; printf("%d\n",ans); return 0;} 推荐例题：【模板】最小生成树]]></content>
  </entry>
  <entry>
    <title><![CDATA[线段树-学习]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言：线段树是一种二叉搜索树，能通关TA实现修改、区间查询等功能……（ 相信大家都懂的……）好吧，在这里，我们就来介绍线段树的单点修改、区间修改以及区间查询的方法。 单点修改，区间查询Emmmmmm 这算是学习线段树的第一步了吧…… _为什么要用线段树去干这件事情呢？你会发现，如果你直接暴力去查询一个区间 [l,r] 的和，那么这样做的时间复杂度将会使O(n)的；但是，如果你用线段树去实现这一过程，那么时间复杂度将会降成O(log n)。 _ 接下来我们就来讲算法的原理。既然线段树被称为“树”，自然是一种树状的数据结构。它的每一个节点都储存了某一个区间的信息。它的结构如图所示： 进行修改时，我们需要更新指定修改节点已经所以与其相关的区间（即包含此节点的所有区间），查询时需查询的区间的值可以有其内部的几个区间的值拼起来得到。代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;malloc.h&gt;#include&lt;cstdio&gt;using namespace std;struct tree{ int sum; tree *lson,*rson;}*root=(tree*)malloc(sizeof(tree));int n,x,y,s,m;void built(tree *tre,int l,int r){ if(l==r) { scanf("%d",&amp;x); tre -&gt; sum = x; return ; } tree *left=(tree*)malloc(sizeof(tree)); tree *right=(tree*)malloc(sizeof(tree)); tre -&gt; lson=left; tre -&gt; rson=right; int mid=(l+r)&gt;&gt;1; built(tre -&gt; lson,l,mid); built(tre -&gt; rson,mid+1,r); tre -&gt; sum=tre -&gt; lson -&gt; sum + tre -&gt; rson -&gt; sum;}void change(tree *tre,int a,int x,int l,int r){ if(x==l&amp;&amp;x==r) { tre -&gt; sum+=a; return ; } tre -&gt; sum += a; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) change(tre -&gt; lson,a,x,l,mid); if(x&gt;mid) change(tre -&gt; rson,a,x,mid+1,r);}int query(tree *tre,int l,int r,int x,int y){ if(x&lt;=l&amp;&amp;y&gt;=r) return tre -&gt; sum; int mid=(l+r)&gt;&gt;1,ans1=0,ans2=0; if(x&lt;=mid) ans1=query(tre -&gt; lson,l,mid,x,y); if(y&gt;mid) ans2=query(tre -&gt; rson,mid+1,r,x,y); return ans1+ans2;}int main(){ scanf("%d%d",&amp;n,&amp;m); built(root,1,n); for(int i=1;i&lt;=m;i++) { scanf("%d%d%d",&amp;s,&amp;x,&amp;y); if(s==1) change(root,y,x,1,n); if(s==2) printf("%d\n",query(root,1,n,x,y)); } return 0;}// PS:我的线段树是用指针写的，如果不喜欢指针可以用数组去实现，节点N的左孩子的下标为2N，右孩子的下标为2N+1。 想做模板题请戳这里（请忽略题目名字，并不是我弄错了，一个模板题的潜力是无穷的） 区间修改，区间查询其实区间修改与单点修改之间只差了一个lazy标记……如果你用多次的单点修改来完成区间修改，那么复杂度将会是O（nlogn），显然还不如你直接修改一个数组快qwq……所以在这个紧急关头，你需要一个lazy标记去拯救你。对于每次区间修改，我们还是从根节点开始找每一个区间，若当前区间[l,r]被需要修改的区间[x,y]完全包含，那么在更新此区间的值的同时，我们还要更新lazy标记，表示该节点的两个子节点需要进行一个大小为lazy的值的修改，但是现在还没有进行。当你打完lazy标记以后，在此次修改中，你就不必再去观该节点的子树了。那么，既然我们打了lazy标记，那么以后肯定还是需要让它起作用的。我们在每次修改和查询过程中，若遍历到某点时，该点的lazy标记不为0，则把标记下放（即根据该节点的lazy标记值去修改其子节点的值，并把该节点的lazy加到其子节点的lazy上。注意，lazy的是加过去，而不是直接覆盖！在标记下放完以后，不要忘了把该节点的lazy标记清空）。附一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;struct tree{ long long sum,lazy; tree *lson,*rson; tree() { lazy = 0; }};long long x,y,k,n,m,s;void built(tree *tre,int l,int r){ tre -&gt; lazy = 0; if(l == r) { scanf("%d",&amp;x); tre -&gt; sum = x; return ; } int mid = (l + r) &gt;&gt; 1; tree *son1 =(tree*) malloc (sizeof(tree)); tree *son2 =(tree*) malloc (sizeof(tree)); tre -&gt; lson = son1; tre -&gt; rson = son2; built(tre -&gt; lson,l,mid); built(tre -&gt; rson,mid + 1,r); tre -&gt; sum = tre -&gt; lson -&gt; sum + tre -&gt; rson -&gt; sum;}void pushdown(tree *tre,int l,int r){ if(l != r) { int mid = (l + r) &gt;&gt; 1; tre -&gt; lson -&gt; lazy = tre -&gt; lson -&gt; lazy + tre -&gt; lazy; tre -&gt; lson -&gt; sum = tre -&gt; lson -&gt; sum + tre -&gt; lazy * (mid - l + 1); tre -&gt; rson -&gt; lazy = tre -&gt; rson -&gt; lazy + tre -&gt; lazy; tre -&gt; rson -&gt; sum = tre -&gt; rson -&gt; sum + tre -&gt; lazy * (r - mid); } tre -&gt; lazy = 0;}void change(tree *tre,int l,int r,int x,int y,int k){ if(l &gt;= x &amp;&amp; r &lt;= y) { tre -&gt; lazy += k; tre -&gt; sum = tre -&gt; sum + k * (r - l + 1); return ; } pushdown(tre,l,r); int mid = (l + r) &gt;&gt; 1; if(x &lt;= mid) change(tre -&gt; lson,l,mid,x,y,k); if(y &gt; mid) change(tre -&gt; rson,mid + 1,r,x,y,k); tre -&gt; sum = tre -&gt; lson -&gt; sum + tre -&gt; rson -&gt;sum;}long long query(tree *tre,int l,int r,int x,int y){ if(l &gt;= x &amp;&amp; r &lt;= y) return tre -&gt; sum; pushdown(tre,l,r); int mid = (l + r) &gt;&gt; 1; long long t1 = 0,t2 = 0; if(x &lt;= mid) t1 = query(tre -&gt; lson,l,mid,x,y); if(y &gt; mid) t2 = query(tre -&gt; rson,mid + 1,r,x,y); return t1 + t2;}int main(){ scanf("%lld%lld",&amp;n,&amp;m); tree *root = (tree*) malloc (sizeof(tree)); built(root,1,n); for(int i = 1;i &lt;= m; i++) { scanf("%lld%lld%lld",&amp;s,&amp;x,&amp;y); if(s == 1) { scanf("%lld",&amp;k); change(root,1,n,x,y,k); } else { long long ans = query(root,1,n,x,y); printf("%lld\n",ans); } } return 0;} 想做模板题请戳这里 线段树除了求和还能干好多事情（如维护区间最大值等），可以自行YY一下下……]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019清北夏令营]]></title>
    <url>%2F2019%2F08%2F02%2F2019%E6%B8%85%E5%8C%97%E5%A4%8F%E4%BB%A4%E8%90%A5%2F</url>
    <content type="text"><![CDATA[数论取整 x是一个实数 floor(x)对x向下取整 ceil(x)对x向上取整 进制转换十进制转m进制用一个数组存转化得到的数，每次将十进制数 %m,得到m进制的最后一位，然后$ / m$，去掉最后一位 m进制转十进制取$v = 0$,每次取m进制数的最高位,使$v = v \times m + a[i]$ 位运算 &lt;&lt; 左移，乘2的n次方 &gt;&gt; 右移，除2的n次方 &amp; 相同位的两个数字都为1，则为1；若有一个不为1，则为0 ·|· 相同位只要一个为1即为1 ^ 操作的结果是如果某位不同则该位为1, 否则该位为0 ~ not运算的定义是把内存中的0和1全部取反 取模基本性质取模可以与加减乘交换顺序（注意除不行） x ≡ y(% p) x+a ≡ y+a (% p) x-a ≡ y-a (% p) （减法需要注意把负数华为正数） xa ≡ ya (% p) (以上假设x≡y (%p)) (a + b)%p = (a%p + b%p)%p (a - b)%p = (a%p – b%p)%p (a - b)%p = (a - b + p)%p ab%p = (a%p)(b%p) %p 正负 一个正整数对一个正整数取模得到的是一个非负整数 一个负数对一个正整数取模得到的是负数或者是0 $a$%$b = a - \lfloor a / b \rfloor * b (a &gt; 0)$ 唯一分解定理唯一分解定理(也称基本算数定理)：任意一个正整数c，将其分解为若干质数的正整数次幂的乘积，该分解方法唯一形如：$c=p1a1p2a2……*pnan$，$p1…pn$均为质数 最大公约数算法公式： code: 1int gcd(int a,int b)&#123;return b == 0 ? a,gcd(b,a % b);&#125; 时间复杂度为$log$级别。 最小公倍数 $lcm=n \times m / gcd(n,m)$ 证明：从质因数分解思考 拓展欧几里得 code： 1234567891011int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b == 0) &#123; x = 1,y = 0; return a; &#125; int g = exgcd(b,a % b,y,x); y -= a / b * x; return g;&#125; 数据结构单调栈 单调栈是指一个栈内部的元素是具有严格单调性的一种数据结构 一般作为工具在预处理数据时使用，或者优化动态规划（决策具有单调性）例题 单调队列 单调队列必须满足从队头到队尾的严格单调性。 排在队列前面的比排在队列后面的要先进队。 一般用于优化动态规划等 例题： code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;malloc.h&gt; #define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;struct tree&#123; int maxx,minn; tree *lson,*rson;&#125;*root = (tree*)malloc(sizeof(tree));struct node&#123; int a,b;&#125;ans[1000005];void build(tree *tre,int l,int r)&#123; if(l == r) &#123; tre -&gt; maxx = read(); tre -&gt; minn = tre -&gt; maxx; return; &#125; int mid = (l + r) &gt;&gt; 1; tree *son1 = (tree*)malloc(sizeof(tree)); tree *son2 = (tree*)malloc(sizeof(tree)); tre -&gt; lson = son1; tre -&gt; rson = son2; build(tre -&gt; lson,l,mid); build(tre -&gt; rson,mid + 1,r); tre -&gt; maxx = max(tre -&gt; lson -&gt; maxx,tre -&gt; rson -&gt; maxx); tre -&gt; minn = min(tre -&gt; lson -&gt; minn,tre -&gt; rson -&gt; minn);&#125;node query(tree *tre,int l,int r,int x,int y)&#123; if(l == r) return (node)&#123;tre -&gt; maxx,tre -&gt; minn&#125;; int mid = (l + r) &gt;&gt; 1; node t1,t2; t1.a = -INF; t1.b = INF; t2.a = -INF; t2.b = INF; if(x &lt;= mid) t1 = query(tre -&gt; lson,l,mid,x,y); if(y &gt; mid) t2 = query(tre -&gt; rson,mid + 1,r,x,y); return (node)&#123;max(t1.a,t2.a),min(t1.b,t2.b)&#125;;&#125;int main()&#123; int n,k; n = read(); k = read(); build(root,1,n); for(int i = 1; i &lt;= n - k + 1; i++) ans[i] = query(root,1,n,i,i + k - 1); for(int i = 1; i &lt;= n - k + 1; i++) printf("%d ",ans[i].b); printf("\n"); for(int i = 1; i &lt;= n - k + 1; i++) printf("%d ",ans[i].a); printf("\n"); return 0;&#125; 莫队$O(nsqrt(n)\times 修改复杂度)$的分治算法，只需要问题满足支持快速单点插入和快速单点删除就行了 例题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define re register#define INF 0x7fffffffusing namespace std;long long read()&#123; long long x = 0,f = 1; char ch; ch = getchar(); while(ch &gt;'9' || ch &lt; '0')&#123;if(ch == '-') f = -f; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;long long gcd(long long a, long long b)&#123;return a == 0 ? b : gcd(b % a, a);&#125;long long n,m,a[50005],xsort,p1,p2,t[50005],ans,cnt,g,ll,rr,in[50005],save1[50005],save2[50005];struct query&#123; long long l,r,num;&#125;q[50005];long long mysort(query x, query y)&#123; if(x.l / xsort == y.l / xsort) return x.r &lt; y.r; return x.l &lt; y.l;&#125;/*inline void del(int k)&#123; if(!in[k]) return ; in[k] = 0; t[a[k]] --; printf("del %d :\n before : %d\n",k,ans); ans = ans - t[a[k]] * (t[a[k]] + 1) + t[a[k]] * (t[a[k]] - 1); printf("after : %d\n",ans);&#125;inline void add(int k)&#123; if(k == 0) return ; if(in[k]) return ; in[k] = 1; t[a[k]] ++; ans = ans + t[a[k]] * 2;&#125;*/long long work(long long x)&#123; return x * x;&#125;void add(long long k)&#123; long long u = a[k]; if(k == 0) return ; //if(in[k]) return ; //in[k] = 1; ans = ans - work(t[u]); t[u] ++; ans = ans + work(t[u]);&#125;void del(long long k)&#123; long long u = a[k]; if(k == 0) return ; //if(in[k] == 0) return ; //in[k] = 0; ans = ans - work(t[u]); t[u] --; ans = ans + work(t[u]);&#125;int main()&#123; n = read(); m = read(); for(re int i = 1; i &lt;= n; i ++) a[i] = read(); for(re int i = 1; i &lt;= m; i++) &#123; q[i].l = read(); q[i].r = read(); q[i].num = i; &#125; xsort = sqrt(n); sort(q + 1, q + m + 1, mysort); for(re int i = 1; i &lt;= m; i++) &#123; ll =q[i].l; rr = q[i].r;// if(ll == rr) &#123;printf("0/1\n"); continue ;&#125; while(p1 &lt; ll)&#123;del(p1); p1 ++;&#125; while(p1 &gt; ll)&#123;p1 --; add(p1);&#125; while(p2 &lt; rr)&#123;p2 ++; add(p2);&#125; while(p2 &gt; rr)&#123;del(p2); p2 --;&#125; cnt = (rr - ll + 1) * (rr - ll); save1[q[i].num] = ans - (rr - ll + 1); save2[q[i].num] = cnt; &#125; for(re int i = 1; i &lt;= m; i++) &#123; if(save1[i] != 0 &amp;&amp; save2[i] != 0) g = gcd(save1[i],save2[i]); else g = 1; if(save1[i] == 0 || save2[i] == 0) &#123;printf("0/1\n"); continue ;&#125; printf("%d/%d\n",save1[i] / g,save2[i] / g); &#125; return 0;&#125; 堆 由于我们有priority_queue,所以手写堆就可以歇着了…… 二叉搜索树 大概就是这样了 由于这东西对于竞赛没什么用（太好卡了，还是去用平衡树吧……），所以不说什么了。 线段树 额…… 对于线段树自我感觉良好，不说废话了qwq。 树链剖分大多数情况下（没有特别说明时），“树链剖分”都指“重链剖分”，我们所讲的也是“重链剖分”。 重链剖分可以将树上的任意一条路径划分成不超过O(logn) 条连续的链，每条链上的点深度互不相同（即是自底向上的一条链，链上所有点的lca为链的一个端点）。重链剖分还能保证划分出的每条链上的节点 dfs 序连续，因此可以方便地用一些维护序列的数据结构（如线段树）来维护树上路径的信息。 1.修改 树上两点之间的路径上 所有点的值。2.查询 树上两点之间的路径上 节点权值的 和/极值/其它（在序列上可以用数据结构维护，便于合并的信息） 。 求LCA 如果两个节点不在同一条链上，将所在链链首深度大的点跳链。当在同一条链时，深度小的点的位置就是lca。 一次跳过一条链，速度比倍增快。 用线段树维护区间值 考虑到树链剖分后每一个链的元素的dfs序是连续的，所以我们可以用线段树取维护树链剖分后的序列。 例题： ZJOI2008 树的统计 对一棵有n个节点，节点带权值的静态树，进行三种操作共q 次： 修改单个节点的值； 查询u到u的路径上的最大值； 查询v到v的路径上的权值和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long long#define INF 0x7fffffff#define re registerusing namespace std;int read()&#123; register int x = 0,f = 1;register char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;ch = getchar();&#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0')&#123;x = x * 10 + ch - 48;ch = getchar();&#125; return x * f;&#125;int n,m,r,s,p,x,y,z,o,t,cnt,ans;int d[200005],siz[200005],fa[200005],dep[200005],son[200005],top[200005],seg[200005],rev[200005],bs[200005];struct edge&#123; int next,to;&#125;e[300005];struct tree&#123; int sum,lazy; tree *lson,*rson;&#125;*root = (tree*)malloc(sizeof(tree));void add(int x,int y)&#123; e[++cnt].to = y; e[cnt].next = d[x]; d[x] = cnt;&#125;void dfs1(int u,int f)&#123; int a,v; siz[u] = 1; fa[u] = f; dep[u] = dep[f] + 1; for(int i = d[u]; i; i = e[i].next) &#123; int j = e[i].to; if(j == f) continue; dfs1(j,u); siz[u] = siz[u] + siz[j]; if(siz[j] &gt; siz[son[u]]) son[u] = j; &#125;&#125;void dfs2(int u,int f)&#123; if(son[u]) &#123; seg[son[u]] = ++t; top[son[u]] = top[u]; rev[t] = son[u]; dfs2(son[u],u); &#125; for(int i = d[u]; i; i = e[i].next) &#123; int j = e[i].to; if(!top[j]) &#123; top[j] = j; seg[j] = ++t; rev[t] = j; dfs2(j,u); &#125; &#125;&#125;void build(tree *tre,int l,int r)&#123; tre -&gt; lazy = 0; if(l == r) &#123; tre -&gt; sum = bs[rev[l]]; return ; &#125; int mid = (l + r) &gt;&gt; 1; tree *son1 = (tree*)malloc(sizeof(tree)); tree *son2 = (tree*)malloc(sizeof(tree)); tre -&gt; lson = son1; tre -&gt; rson = son2; build(tre -&gt; lson,l,mid); build(tre -&gt; rson,mid + 1,r); tre -&gt; sum = (tre -&gt; lson -&gt; sum + tre -&gt; rson -&gt; sum) % p;&#125;void pushdown(tree *tre,int l,int r)&#123; if(l == r || tre -&gt; lazy == 0) return ; int mid = (l + r) &gt;&gt; 1; tre -&gt; lson -&gt; sum = (tre -&gt; lson -&gt; sum + 1ll *(mid - l + 1) * tre -&gt; lazy) % p; tre -&gt; rson -&gt; sum = (tre -&gt; rson -&gt; sum + 1LL *(r - mid) * tre -&gt; lazy) % p; tre -&gt; lson -&gt; lazy = (tre -&gt; lson -&gt; lazy + tre -&gt; lazy) % p; tre -&gt; rson -&gt; lazy = (tre -&gt; rson -&gt; lazy + tre -&gt; lazy) % p; tre -&gt; lazy = 0;&#125;void change(tree *tre,int l,int r,int x,int y,int k)&#123; if(l &gt;= x &amp;&amp; r &lt;= y) &#123; tre -&gt; sum = (tre -&gt; sum + 1LL * (r - l + 1) * k) % p; tre -&gt; lazy = (tre -&gt; lazy + k) % p; return ; &#125; pushdown(tre,l,r); int mid = (l + r) &gt;&gt; 1; if(x &lt;= mid) change(tre -&gt; lson,l,mid,x,y,k); if(y &gt; mid) change(tre -&gt; rson,mid + 1,r,x,y,k); tre -&gt; sum = (tre -&gt; lson -&gt; sum + tre -&gt; rson -&gt; sum) % p;&#125;int query(tree *tre,int l,int r,int x,int y)&#123; if(l &gt;= x &amp;&amp; r &lt;= y) return tre -&gt; sum; pushdown(tre,l,r); int mid = (l + r) &gt;&gt; 1,t1 = 0,t2 = 0; if(x &lt;= mid) t1 = query(tre -&gt; lson,l,mid,x,y) % p; if(y &gt;mid) t2 = query(tre -&gt; rson,mid + 1,r,x,y) % p; return (t1 + t2) % p;&#125;void myswap()&#123; o = x; x = y; y = o;&#125;int main()&#123; n = read(); m = read(); r = read(); p = read(); for(int i = 1; i &lt;= n; i++) bs[i] = read(); for(int i = 1; i &lt; n; i++) &#123; x = read(); y = read(); add(x,y); add(y,x); &#125; dfs1(r,0); seg[r] = ++t; rev[t] = r; top[r] = r; dfs2(r,0); build(root,1,n); for(int i = 1; i &lt;= m; i++) &#123; s = read(); ans = 0; if(s == 1) &#123; x = read(); y = read(); z = read(); while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) myswap(); change(root,1,n,seg[top[x]],seg[x],z); x = fa[top[x]]; &#125; if(seg[x] &gt; seg[y]) myswap(); change(root,1,n,seg[x],seg[y],z); &#125; if(s == 2) &#123; x = read(); y = read(); while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) myswap(); ans = (ans + query(root,1,n,seg[top[x]],seg[x])) % p; x = fa[top[x]]; &#125; if(seg[x] &gt; seg[y]) myswap(); ans = (ans + query(root,1,n,seg[x],seg[y])) % p; printf("%d\n",ans); &#125; if(s == 3) &#123; x = read(); z = read(); change(root,1,n,seg[x],seg[x] + siz[x] - 1,z); &#125; if(s == 4) &#123; x = read(); ans = query(root,1,n,seg[x],seg[x] + siz[x] - 1) % p; printf("%d\n",ans); &#125; &#125; return 0;&#125; 树状数组他死了 ST表倍增做法：预处理出f[i][j]表示从i开始，连续2^j个中的最小值 对比线段树：需要区间可合并 树状数组：需要区间可合并，并满足区间减法，不支持区间修改（min,max不满足区间减法） ST算法：需要区间可合并，不支持修改 线段树的要求最少，但代码最多 线段树适用范围最广，但速度最慢 图论有向无环图&amp;拓扑排序 不存在环的有向图被称为有向无环图（ Directed Acyclic Graph） 在有向无环图上，我们可以对节点进行排序，生成一个线性序列，使得：如果节点i在该有向无环图上可以沿着有向边到达节点j，那么节点i在线性序列中的位置一定在节点j之前生成线性序列的过程被称为拓扑排序 有向图 G 可以进行拓扑排序 等价于 有向图G是有向无环图 拓扑排序的简单应用：给出有向无环图G和一个点S，求S到G上其它所有点的路径的方案数 例题 P1347排序 https://www.luogu.org/problemnew/show/P2047https://www.luogu.org/problemnew/show/P2966 缩点强联通分量 强连通的定义：有向图 G 强连通是指，G 中任意两个结点连通。 强连通分量（Strongly Connected Components，SCC）的定义是：极大的强连通子图 强连通分量+缩点+DGA上的动态规划是解决一系列有向图问题通用方法 tarjan 如果结点u是某个强连通分量在搜索树中遇到的第一个结点，那么这个强连通分量的其余结点肯定是在搜索树中以u为根的子树中。u被称为这个强连通分量的根。这一点我们可以用反证法证明，即如果一个和u在同一个强联通分量中的点不在以遇到的第一个节点u的子树中，那么它一定比u先被搜索到。 code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//https://www.luogu.org/problemnew/show/P3387#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;int read()&#123; int x = 0,f = 1; char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;x = x * 10 + ch - 48; ch = getchar();&#125; return x * f;&#125;int cnt,cn,n,sc,p[100005],sz[100005],dfncnt,m,scc[100005],sta[100005],dfn[100005],low[100005],dfcnt,s[100005],tp,d[100005],h[100005],di[100005];struct EDGE&#123; int from,to,next;&#125;edge[500005],e[500005];void add(int x,int y)&#123; e[++cnt].from = x; e[cnt].to = y; e[cnt].next = d[x]; d[x] = cnt;&#125;void tarjan(int u)&#123; low[u] = dfn[u] = ++dfncnt,s[++tp] = u;// cout &lt;&lt; s[tp] &lt;&lt; " stp" &lt;&lt; endl; for(int i = d[u]; i; i = e[i].next) &#123; int v = e[i].to; if(!dfn[v]) tarjan(v),low[u] = min(low[u],low[v]); else if(!scc[v]) low[u] = min(low[u],dfn[v]); &#125; if(dfn[u] == low[u])&#123; while(s[tp] != u) &#123; p[u] += p[s[tp]],scc[s[tp]] = u,sz[u] ++,--tp; &#125; scc[s[tp]] = u,sz[u] ++, --tp; &#125;&#125;int dist[100005];int topo()&#123; queue&lt;int&gt; que; int tot = 0; for(int i = 1; i &lt;= n; i++) if(scc[i] == i &amp;&amp; !di[i])&#123; que.push(i); dist[i] = p[i]; &#125; while(!que.empty())&#123; int k = que.front(); que.pop(); for(int i = h[k]; i; i = edge[i].next)&#123; int v = edge[i].to; dist[v] = max(dist[v],dist[k] + p[v]); di[v] --; if(di[v] == 0) que.push(v); &#125; &#125; int ans = 0; for(int i = 1; i &lt;= n; i++) ans = max(ans,dist[i]); return ans;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d",&amp;p[i]); for(int i = 1; i &lt;= m; i++)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); add(x,y); &#125; for(int i = 1; i &lt;= n; i++) if(!dfn[i]) tarjan(i); for(int i = 1; i &lt;= m; i++)&#123; int x = scc[e[i].from],y = scc[e[i].to]; if(x != y)&#123; edge[++cn].next = h[x]; edge[cn].to = y; edge[cn].from = x; h[x] = cn; di[y] ++; &#125; &#125; printf("%d\n",topo()); return 0;&#125; Kosaraju算法 另一个比tarjan更好理解的求强联通分量的算法。 Kosaraju 算法依靠两次简单的 DFS 实现。 第一次 DFS，选取任意顶点作为起点，遍历所有为访问过的顶点，并在回溯之前给顶点编号，也就是后序遍历。 第二次 DFS，对于反向后的图，以标号最大的顶点作为起点开始 DFS。这样遍历到的顶点集合就是一个强连通分量。对于所有未访问过的结点，选取标号最大的，重复上述过程。 两次 DFS 结束后，强连通分量就找出来了 证明： 如果点A在连正向边时可以到达点B，点A在连反向边时也能到达点B，那么我们就可以判断，点A和点B是可以互相到达的。 code： 1234567891011121314151617181920212223242526272829void positive_dfs(int pos)&#123; DFN++; vis[pos]=1; for(int i=pre[1][pos];i;i=E[1][i].next) if(!vis[E[1][i].to]) positive_dfs(E[1][i].to); stack[N*2+1-(++DFN)]=pos;&#125;void negative_dfs(int pos)&#123; dye[pos]=CN; vis[pos]=0; size[dye[pos]]++; for(int i=pre[2][pos];i;i=E[2][i].next) if(vis[E[2][i].to]) negative_dfs(E[2][i].to);&#125;int main()&#123; ...... for(int i=1;i&lt;=N;i++) if(!vis[i]) positive_dfs(i); for(int i=1;i&lt;=N*2;i++) if(stack[i]&amp;&amp;vis[stack[i]])&#123; CN++; negative_dfs(stack[i]); &#125; ...... &#125; 推荐习题：https://www.luogu.org/problemnew/show/P1262 二分图定义&amp;性质 节点由两个集合组成，且两个集合内部没有边的无向图 重要性质：二分图不包括奇环。可用来做二分图的判定匈牙利算法求最大匹配每次寻找增广路径，都可以使得匹配数+1因此，不断递归寻找可能存在的增广路径，就可以得到二分图的最大匹配 如图，这就是一条增广路，粗边为选中的边。我们可以发现，对于一条增广路，如果我们删掉选中的边，加入未选的边，边数（匹配数）就会加1。 查分约束差分约束系统：由N个变量X_1, X_2, X_3 …. X_N和M个未知条件组成的N元一次不等式组，其中，每个条件都形如X_i &lt;= X_j + c_k我们的问题是：给出一组满足所有条件的解，否则判断出无解 注意到，X_i &lt;= X_j + c_k 与单源最短路中的三角不等式很相似，建立N个节点对应N个变量。对于每组条件，从 j 向i连一条边。同时虚构0号节点并向每一个节点连一条边，如果存在负环则无解。否则有解。 最近公共祖先考虑到一步一步跳太慢，我们考虑有没有快一点的跳法设fa[i][j] 表示节点i 的第2^j 个祖先是谁，fa[x][i] 可以预处理得到 考虑如何对朴素算法进行优化：1。 调整到同一高度2。 一起同时往上跳 略微占空间，并不是最优的LCA算法 code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int n,m,s,x,y,cnt,d[1000005],f[500005][50],dp[500005];struct edge&#123; int to,next;&#125;e[1000005];void add(int x,int y)&#123; e[++cnt].to = y; e[cnt].next = d[x]; d[x] = cnt;&#125;void dfs(int u,int fa)&#123; dp[u] = dp[fa] + 1; f[u][0] = fa; for(int i = 1; i &lt;= 23; i++) f[u][i] = f[f[u][i - 1]][i - 1]; for(int i = d[u]; i; i = e[i].next) &#123; if(e[i].to == fa) continue; dfs(e[i].to,u); &#125;&#125;int lca(int a,int b)&#123; if(dp[a] &gt; dp[b]) swap(a,b); int dis = dp[b] - dp[a]; for(int i = 22; i &gt;= 0; i--) &#123; int d = 1 &lt;&lt; i; if(d &lt;= dis) &#123; dis -= d; b = f[b][i]; &#125; &#125; if(a == b) return a; for(int i = 22; i &gt;= 0; i--) &#123; if(f[a][i] == f[b][i]) continue ; a = f[a][i]; b = f[b][i]; &#125; return f[a][0];&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;s); for(int i = 1; i &lt; n; i++) &#123; scanf("%d%d",&amp;x,&amp;y); add(x,y); add(y,x); &#125; dfs(s,0); for(int i = 1; i &lt;= m; i ++) &#123; scanf("%d%d",&amp;x,&amp;y); printf("%d\n",lca(x,y)); &#125; return 0;&#125; 贪心基本思想贪心是一种解题策略，更多是一种解题思想 使用贪心方法需要注意局部最优与全局最优的关系（用于区分贪心和动态规划），选择当前状态的局部最优并不一定能推导出问题的全局最优 利用贪心策略解题，需要解决两个问题：该题是否适合于用贪心策略求解。如何选择贪心标准，以得到问题的最优解 。 贪心问题的特点可以通过局部的贪心选择来达到问题的全局最优解，运用贪心策略解题，一般来说需要一步步的进行多次的贪心选择。在经过一次贪心选择后，原问题将变成一个相似的，但规模更小的问题，之后的每一步都是当前看似最佳的选择，且每一个选择都仅做一次。 原问题的最优解包含子问题的最优解，即具有最优子结构的性质，但并不是所有具有最优子结构的问题都可以用贪心策略求解。 分治思想分治分治，分而治之，分治算法就是将一个大问题划分为几个更小规模的形式相同的子问题并加以解决，通过解决子问题最后解决总问题。分治算法在OI中的运用主要在两个方面 二分查找、三分查找、二分答案 直接考察分治 二分答案常见于最小值最大或者最大值最小问题（基本上可以把这看做二分答案的标志）要求： 如果答案确定，我们能够快速判断答案是否合法 答案具有可二分性，即如果答案为i是可行的，答案为i+1即可行作用牺牲log(n)的复杂度，把求最优化问题变成了一个判断是否可行的问题，有时候能够简化问题。关键在于转化后的问题更好求解。 三分三分的难度要略低于二分(因为扩展出来的形式少)三分的用处在于求一个单峰函数的最值单峰函数，例如： code: 动态规划一维线性DP 比较常见的一种动态规划问题，特点是状态只有一维 例题： 但是时间复杂度是$O(n^2)$。 优化： 记录f[x]为当前时刻dp值为x的所有元素中高度最高的一个，用单调栈去优化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#define INF 0x7fffffff using namespace std;int n,a[100005],sta[100005],t;void two_fen(int k)&#123; int l = 1, r = t, mid; while(l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if(sta[mid] &gt;= k) l = mid + 1; else r = mid - 1; &#125; sta[l] = k;&#125;void work()&#123; sta[0] = INF; t = 0; for(int i = 1; i &lt;= n; i++) &#123; if(a[i] &lt;= sta[t]) sta[++t] = a[i]; else two_fen(a[i]); &#125; //for(int i = 1; i &lt;= t; i++) cout &lt;&lt; sta[i] &lt;&lt; " ";cout &lt;&lt;endl; printf("%d\n",t);&#125;void count()&#123; memset(sta,0,sizeof(sta)); int j,place,x; t = 0; for(int i = 1; i &lt;= n; i++) &#123; place = 0; x = INF; for(int j = 1; j &lt;= t; j++) if(sta[j] &gt;= a[i] &amp;&amp; (sta[j] &lt; sta[place] || place == 0)) place = j; if(place == 0) sta[++t] = a[i]; else sta[place] = a[i]; &#125; printf("%d\n",t);&#125;int main()&#123; while(cin &gt;&gt; a[++n]); n --; work(); count(); return 0; &#125; 设d[i]为长度为n的错排的种类数，考虑构造一个错排序列。 $d[1] = 0$ $d[2] = 1$ $d[n]=(d[n-1] + d[n-2])*(n-1) (n &gt;= 3)$ $f[n] = f[n-1] + f[n-2]*2$ 考虑这样几种情况： 运一个人：a[n] ： $t=a[1]+a[n]$ 但这样不是最优的 若还剩a[n]和a[n-1]，则一个一个运： $t=a[1]+a[n-1]+a[1]+a[n]$ 但如果让a[n]和a[n-1]一起走，则： $t=a[1]+a[n]+a[2]+a[2]$ 所以我们有两种方案： 第一种 让过河时间最少的人过来送手电筒，然后带着你一起过河。 第二种 让过河时间最少的人过来送手电筒，然后你带着n-1号一起过河，此时手电筒在对岸，接着让过河时间第二少的人过来送手电筒，带着过河时间最少的人一起过河。 所以我们建立一个dp[i]来记录前i个人过河的最短时间。那么转换方程为$$dp[i] = min(p[i - 1] + a[0] + a[i], dp[i -2] + a[0] + a[i] + 2 * a[1]);$$ 背包问题 严格来说，背包问题并不是一个单独的问题，他是一系列比较类似的问题的总称 请注意，并非所有的背包问题都是动态规划问题 0-1背包 有N件物品和一个容量为V的背包。第i件物品的价格（即体积，下同）是w[i]，价值是c[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 对于一个物品，只有两种情况 情况一: 第i件不放进去，这时所得价值为:$f[i-1][v]$ 情况二: 第i件放进去，这时所得价值为：$f[i-1][v-c[i]]+w[i] $状态转移方程为：$f[i][v] = max(f[i-1][v], f[i-1][v-w[i]]+c[i])$ 最终的答案是 $Max(f[N][j] for\ j \ in [0,maxV])$ code: 1234int f[100005];for(int i = 1; i &lt;= n; i++) for(int j = v; j &gt;= w[i]; j--) f[i][j] = max(f[i][j],f[i][j - w[i]] + v[i]); 完全背包 N件物品和一个容量为V的背包。第i种物品的价格（即体积，下同）是w[i]，价值是c[i]，每种物品有无限多个。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 完全背包和01背包十分相像， 区别就是完全背包物品有无限件。由之前的选或者不选转变成了选或者不选，选几件。 用f[i][j]表示前i种背包装入容量为j的背包中所可以获得的最大价值 对于一种物品，只有两种情况 情况一: 第i件不放进去，这时所得价值为:$f[i-1][v]$ 情况二: 第i件放进去，这时，我们需要枚举放进去多少件，设为K，所得价值为：$f[i-1][v-Kc[i]]+Kw[i] $状态转移方程为：$f[i][v] = max(f[i-1][v-Kw[i]]+Kc[i]) 0&lt;=K&lt;=v/w[i]$ 最终的答案是 $Max(f[N][j] for \ j \ in [0,maxV])$ code: 123for(int i = 1; i &lt;= n; i++) for(int j = w[i]; j &lt;= v; j++) f[i][j] = max(f[i][j],f[i][j - w[i]] + v[i]); 多重背包 有N件物品和一个容量为V的背包。第i种物品的价格（即体积，下同）是w[i]，价值是c[i]，第i种物品最多有n[i]件可用。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。用f[i][j]表示前i种背包装入容量为j的背包中所可以获得的最大价值 对于一种物品，只有两种情况 情况一: 第i件不放进去，这时所得价值为:$f[i-1][v]$ 情况二: 第i件放进去，这时，我们需要枚举放进去多少件，设为K，所得价值为：$f[i-1][v-Kc[i]]+Kw[i]$状态转移方程为：$f[i][v] = max(f[i-1][v-Kw[i]]+Kc[i]) 0&lt;=K&lt;=v/w[i]，K&lt;= n[i]$ 最终的答案是 $Max(f[N][j] for \ j \ in [0,maxV])$ 那么，这样做的时间复杂度是多少呢？ $O(nW\sum k_i)$ 轻松TLE没商量。 所以我们要对此进行二进制分解优化，处理后我们可以把多重背包转化成 0-1 背包模型来求解。 为了表述方便，我们用$A_{i,j}$表示第$i$种物品拆分出的第$j$个物品。 我们令$A_{i,j}$ 表示由$2^j$的单个物品组合成的一个更大的物品。如果$k_i+1$不是2的整数次幂，就需要再添加一个物品，该物品由二进制分解后剩余的物品组成。 举个例子： $6=1+2+3$ $8=1+2+4+1$ $18=1+2+4+8+3$ $31=1+2+4+8+16$ 显然，通过上述拆分方式，可以表示任意 $\leq k$个物品的等效选择方式。将每种物品按照上述方式拆分后，使用 0-1 背包的方法解决即可。 时间复杂度$O(nW\sum log \ k_i)$ code: 12345678910111213index = 0;for(int i = 1; i &lt;= m; i++) &#123; int c = 1, p, h, k; cin &gt;&gt; p &gt;&gt; h &gt;&gt; k; while(k - c &gt; 0) &#123; k -= c; list[++index].w = c * p; list[index].v = c * h; c *= 2; &#125; list[++index].w = p * k; list[index].v = h * k;&#125; 分组背包 有N件物品和一个容量为V的背包。第i件物品的价格（即体积，下同）是w[i]，价值是c[i]。这N个物品分成了若干个组，每个组里面的商品不可以同时选择。 求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 code: 12345678910for(int i=1;i&lt;=N;i++)&#123; for(int j=1;j&lt;=A[i];j++)&#123; for(int k=0;k&lt;=V;k++)&#123; dp[i][k] = max(dp[i][k], dp[i-1][k]); if(k&gt;=v[i][j])&#123; dp[i][k] = max(dp[i][k], dp[i-1][k-v[i][j]]+c[i][j]); &#125; &#125; &#125; &#125; 树形DP这个地方是真的听懵了……以后再填坑吧…… 例题1： 树上的动态规划如何写状态函数，怎么转移？ 一般来说，绝大多数树上的一个节点i的状态函数都是对于以该点为根的子树的状态的概括。 好处：边界条件清晰（叶节点），无后效性，子树内部的具体情况与外界无关 以本题为例子： 总活跃指数最大（整棵树的活跃指数最大） —- 子树的活跃指数最大是多少？ code: 基环树 思路：先找到环，环以外的部分正常的树dp做，然后考虑断环 推荐习题 https://www.luogu.org/problemnew/show/P2607 状压DP code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int read()&#123; int x = 0,f = 1; char ch; ch = getchar(); while(ch &gt; '9' || ch &lt; '0')&#123;if(ch == '-') f = -f;&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;x = x * 10 + ch - 48; ch = getchar();&#125; return x * f;&#125;int n,cnt,kk,zt[2000],l[2000];long long ans,f[10][20000][100];void dfs(int j,int p,int s)&#123; if(p &gt;= n) &#123; zt[++cnt] = j; l[cnt] = s; return ; &#125; dfs(j,p + 1,s); dfs(j + (1 &lt;&lt; p),p + 2,s + 1);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;kk); dfs(0,0,0); for(int i = 1;i &lt;= cnt; i++) f[1][i][l[i]] = 1; for(int i = 2;i &lt;= n; i++) for(int j = 1; j &lt;= cnt; j++) for(int k = 1; k &lt;= cnt; k++) &#123; if(zt[j] &amp; zt[k]) continue; if((zt[j] &lt;&lt; 1) &amp; zt[k]) continue; if(zt[j] &amp; (zt[k] &lt;&lt; 1)) continue; for(int s = kk; s &gt;= l[j]; s--) f[i][j][s] += f[i - 1][k][s - l[j]]; &#125; for(int i = 1; i &lt;= cnt; i++) ans += f[n][i][kk]; printf("%lld\n",ans); return 0;&#125; 数位DP问题模型：给定两个很大的正整数 a,b, 求在[a,b]内有多少数字满足性质 xxxxx 我们用f数组记录第i位以j开头的方案总数，然后累加就好了，这里就不详细说了（因为我真的不会……）。code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdlib&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;long long F[12][10];int my_abs(int x)&#123;return x&lt;0?-x:x;&#125;long long GetAns(long long x)&#123; if(x==0)return 1; long long ans = 0; long long now=0; int tmp[12],ct=0; long long t = x; while(t&gt;0)&#123;ct+=1;t=t/10;&#125; t = x; for(int i=1;i&lt;=ct;i++)&#123; tmp[i] = t%10; t=t/10; &#125; now=1; for(int i=1;i&lt;ct;i++)&#123; for(int j=1;j&lt;=9;j++)&#123; ans += F[i][j]; &#125; &#125; for(int i=ct;i&gt;=1;i--)&#123; if(ct==i)&#123; for(int j=1;j&lt;tmp[i];j++)&#123; ans = ans + F[i][j]; &#125; &#125; else &#123; for(int j=0;j&lt;tmp[i];j++)&#123; if(my_abs(j-tmp[i+1])&lt;2)&#123; continue; &#125; ans = ans + F[i][j]; &#125; if(my_abs(tmp[i]-tmp[i+1])&lt;2)&#123; break; &#125; &#125; &#125; return ans;&#125;int main()&#123; for(int i=0;i&lt;=9;i++)F[1][i] = 1; for(int i=2;i&lt;12;i++)&#123; for(int j=0;j&lt;=9;j++)&#123; F[i][j]=0; for(int k=0;k&lt;=9;k++)&#123; if(my_abs(j-k)&lt;2)&#123; continue; &#125; F[i][j] += F[i-1][k]; &#125; &#125; &#125; long long L, R; cin &gt;&gt; L&gt;&gt;R; cout&lt;&lt;GetAns(R+1)-GetAns(L)&lt;&lt;endl; return 0;&#125; 对拍想要对拍，我们需要这样几个部分： 想要判断对错的代码 暴力代码 一个数据生成器 一个用来对拍的程序 我们以这个题为例 不确认对错的代码： 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; freopen(&quot;a.in&quot;, &quot;r&quot;, stdin); freopen(&quot;a.out&quot;, &quot;w&quot;, stdout); long long a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a * b - a - b &lt;&lt; endl; return 0;&#125; 暴力代码： 12345678910111213141516171819202122232425#include &lt;cstdio&gt;using namespace std;bool ok(int n, int a, int b)&#123; for (int x = n/a; x &gt;= 0; -- x) if ((n - a * x) % b == 0) return true; return false;&#125;int main()&#123; freopen("a.in", "r", stdin); freopen("a_std.out", "w", stdout); int a, b; scanf("%d%d", &amp;a, &amp;b); for (int i = 1000000; i &gt;= 0; -- i) if (! ok(i, a, b)) &#123; printf("%d\n", i); break; &#125; return 0;&#125; 数据生成器： 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;using namespace std;int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b, a%b);&#125;int main()&#123; srand((int)time(0)); freopen(&quot;a.in&quot;, &quot;w&quot;, stdout); int a, b; do &#123; a = rand() % 50 + 2; b = rand() % 50 + 2; &#125; while (gcd(a, b) &gt; 1); cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; return 0;&#125; 对拍程序： 12345678@echo off:1genabrute_forcefc a.out a_std.outif %errorlevel% == 0 goto pause]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>动态规划</tag>
        <tag>数论</tag>
        <tag>贪心</tag>
        <tag>数据结构</tag>
        <tag>分治</tag>
        <tag>对拍</tag>
      </tags>
  </entry>
</search>
